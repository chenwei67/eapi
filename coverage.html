
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>eapi: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/chenwei67/eapi/analyzer.go (0.0%)</option>
				
				<option value="file1">github.com/chenwei67/eapi/comment.go (0.0%)</option>
				
				<option value="file2">github.com/chenwei67/eapi/context.go (14.3%)</option>
				
				<option value="file3">github.com/chenwei67/eapi/definition.go (0.0%)</option>
				
				<option value="file4">github.com/chenwei67/eapi/entrypoint.go (0.0%)</option>
				
				<option value="file5">github.com/chenwei67/eapi/environment.go (0.0%)</option>
				
				<option value="file6">github.com/chenwei67/eapi/generator_executor.go (0.0%)</option>
				
				<option value="file7">github.com/chenwei67/eapi/logger.go (1.4%)</option>
				
				<option value="file8">github.com/chenwei67/eapi/mod.go (0.0%)</option>
				
				<option value="file9">github.com/chenwei67/eapi/param_parser.go (0.0%)</option>
				
				<option value="file10">github.com/chenwei67/eapi/route.go (0.0%)</option>
				
				<option value="file11">github.com/chenwei67/eapi/schema_builder.go (0.0%)</option>
				
				<option value="file12">github.com/chenwei67/eapi/stack.go (0.0%)</option>
				
				<option value="file13">github.com/chenwei67/eapi/utils.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package eapi

import (
        "fmt"
        "go/ast"
        "go/token"
        "go/types"
        "os"
        "path/filepath"
        "strings"

        "github.com/chenwei67/eapi/spec"
        "github.com/knadh/koanf"
        "github.com/samber/lo"
        "golang.org/x/mod/modfile"
        "golang.org/x/tools/go/packages"
)

type Analyzer struct {
        routes      APIs
        globalEnv   *Environment
        plugins     []Plugin
        definitions Definitions
        depends     []string
        k           *koanf.Koanf
        strictMode  bool

        doc      *spec.T
        packages []*packages.Package
}

func NewAnalyzer(k *koanf.Koanf) *Analyzer <span class="cov0" title="0">{
        a := &amp;Analyzer{
                routes:      make(APIs, 0),
                globalEnv:   NewEnvironment(nil),
                plugins:     make([]Plugin, 0),
                definitions: make(Definitions),
                k:           k,
        }

        components := spec.NewComponents()
        components.Schemas = make(spec.Schemas)
        doc := &amp;spec.T{
                OpenAPI:    "3.0.3",
                Info:       &amp;spec.Info{},
                Components: components,
                Paths:      make(spec.Paths),
        }
        a.doc = doc

        return a
}</span>

func (a *Analyzer) Plugin(plugins ...Plugin) *Analyzer <span class="cov0" title="0">{
        for _, plugin := range plugins </span><span class="cov0" title="0">{
                err := plugin.Mount(a.k)
                if err != nil </span><span class="cov0" title="0">{
                        panic(fmt.Sprintf("mount plugin '%s' failed. error: %s", plugin.Name(), err.Error()))</span>
                }
        }

        <span class="cov0" title="0">a.plugins = append(a.plugins, plugins...)
        return a</span>
}

func (a *Analyzer) Depends(pkgNames ...string) *Analyzer <span class="cov0" title="0">{
        a.depends = append(a.depends, pkgNames...)
        return a
}</span>

func (a *Analyzer) WithStrictMode(strict bool) *Analyzer <span class="cov0" title="0">{
        a.strictMode = strict
        return a
}</span>

func (a *Analyzer) Process(packagePath string) *Analyzer <span class="cov0" title="0">{
        LogDebug("Process: 开始处理包路径 %s", packagePath)

        if len(a.plugins) &lt;= 0 </span><span class="cov0" title="0">{
                panic("must register plugin before processing")</span>
        }

        <span class="cov0" title="0">packagePath, err := filepath.Abs(packagePath)
        if err != nil </span><span class="cov0" title="0">{
                panic("invalid package path: " + err.Error())</span>
        }
        <span class="cov0" title="0">LogDebug("Process: 绝对路径解析完成: %s", packagePath)

        // 使用defer来捕获可能的panic
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        LogError("Process: 发生panic: %v", r)
                        panic(r)</span> // 重新抛出panic
                }
        }()

        <span class="cov0" title="0">var visited = make(map[string]struct{})
        LogDebug("Process: 开始加载包")
        pkgList := a.load(packagePath)
        LogInfo("Process: 包加载完成，共%d个包组", len(pkgList))

        for pkgGroupIdx, pkg := range pkgList </span><span class="cov0" title="0">{
                LogDebug("Process: 处理第%d个包组，包含%d个包", pkgGroupIdx+1, len(pkg))
                a.definitions = make(Definitions)

                LogDebug("Process: 开始加载定义")
                for pkgIdx, p := range pkg </span><span class="cov0" title="0">{
                        LogDebug("Process: 加载第%d个包的定义: %s", pkgIdx+1, p.PkgPath)
                        a.loadDefinitionsFromPkg(p, p.Module.Dir)
                        LogDebug("Process: 完成第%d个包的定义加载: %s", pkgIdx+1, p.PkgPath)
                }</span>
                <span class="cov0" title="0">LogDebug("Process: 定义加载完成")

                LogDebug("Process: 开始处理文件")
                for pkgIdx, pkg := range pkg </span><span class="cov0" title="0">{
                        LogDebug("Process: 处理第%d个包: %s", pkgIdx+1, pkg.PkgPath)
                        moduleDir := pkg.Module.Dir
                        InspectPackage(pkg, func(pkg *packages.Package) bool </span><span class="cov0" title="0">{
                                LogDebug("Process: 检查包: %s", pkg.PkgPath)
                                if _, ok := visited[pkg.PkgPath]; ok </span><span class="cov0" title="0">{
                                        LogDebug("Process: 包已访问，跳过: %s", pkg.PkgPath)
                                        return false
                                }</span>
                                <span class="cov0" title="0">visited[pkg.PkgPath] = struct{}{}
                                if pkg.Module == nil || pkg.Module.Dir != moduleDir </span><span class="cov0" title="0">{
                                        LogDebug("Process: 包模块不匹配，跳过: %s", pkg.PkgPath)
                                        return false
                                }</span>
                                <span class="cov0" title="0">if DEBUG </span><span class="cov0" title="0">{
                                        LogDebug("inspect %s", pkg.PkgPath)
                                }</span>

                                <span class="cov0" title="0">LogDebug("Process: 创建上下文并处理文件，包: %s，文件数: %d", pkg.PkgPath, len(pkg.Syntax))
                                ctx := a.context().Block().WithPackage(pkg)
                                for fileIdx, file := range pkg.Syntax </span><span class="cov0" title="0">{
                                        LogDebug("Process: 处理第%d个文件", fileIdx+1)
                                        a.processFile(ctx.Block().WithFile(file), file, pkg)
                                        LogDebug("Process: 完成第%d个文件处理", fileIdx+1)
                                }</span>
                                <span class="cov0" title="0">LogDebug("Process: 完成包处理: %s", pkg.PkgPath)

                                return true</span>
                        })
                        <span class="cov0" title="0">LogDebug("Process: 完成第%d个包的所有处理: %s", pkgIdx+1, pkg.PkgPath)</span>
                }
                <span class="cov0" title="0">LogDebug("Process: 完成第%d个包组的文件处理", pkgGroupIdx+1)</span>
        }

        <span class="cov0" title="0">LogInfo("Process: 所有处理完成")
        return a</span>
}

func (a *Analyzer) APIs() *APIs <span class="cov0" title="0">{
        return &amp;a.routes
}</span>

func (a *Analyzer) Doc() *spec.T <span class="cov0" title="0">{
        return a.doc
}</span>

func (a *Analyzer) analyze(ctx *Context, node ast.Node) <span class="cov0" title="0">{
        for _, plugin := range a.plugins </span><span class="cov0" title="0">{
                plugin.Analyze(ctx, node)
        }</span>
}

const entryPackageName = "command-line-arguments"

func (a *Analyzer) load(pkgPath string) [][]*packages.Package <span class="cov0" title="0">{
        LogDebug("load: 开始加载包路径 %s", pkgPath)

        absPath, err := filepath.Abs(pkgPath)
        if err != nil </span><span class="cov0" title="0">{
                panic("invalid package path: " + pkgPath)</span>
        }
        <span class="cov0" title="0">LogDebug("load: 绝对路径: %s", absPath)

        // 使用defer来捕获可能的panic
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        LogError("load: 发生panic: %v", r)
                        panic(r)</span> // 重新抛出panic
                }
        }()

        <span class="cov0" title="0">LogDebug("load: 创建packages.Config")
        config := &amp;packages.Config{
                Mode: packages.NeedName |
                        packages.NeedImports |
                        packages.NeedDeps |
                        packages.NeedTypes |
                        packages.NeedSyntax |
                        packages.NeedModule |
                        packages.NeedTypesInfo |
                        0,
                BuildFlags: []string{},
                Tests:      false,
                Dir:        absPath,
                Env:        os.Environ(),
        }
        LogDebug("load: packages.Config创建完成")

        // 使用 ./... 模式加载当前目录及所有子目录的包
        LogDebug("load: 使用./...模式调用packages.Load")
        packs, err := packages.Load(config, "./...")
        if err != nil </span><span class="cov0" title="0">{
                LogError("load: packages.Load失败: %v", err)
                panic("load packages failed: " + err.Error())</span>
        }
        <span class="cov0" title="0">LogDebug("load: packages.Load成功，返回%d个包", len(packs))

        // 打印每个包的详细信息用于调试
        for i, p := range packs </span><span class="cov0" title="0">{
                LogDebug("load: 包%d - ID: %s, PkgPath: %s, Name: %s", i+1, p.ID, p.PkgPath, p.Name)
                if p.Module != nil </span><span class="cov0" title="0">{
                        LogDebug("load: 包%d - Module: %s (Dir: %s)", i+1, p.Module.Path, p.Module.Dir)
                }</span> else<span class="cov0" title="0"> {
                        LogDebug("load: 包%d - 无Module信息", i+1)
                }</span>
                <span class="cov0" title="0">LogDebug("load: 包%d - 语法文件数: %d", i+1, len(p.Syntax))
                if len(p.Errors) &gt; 0 </span><span class="cov0" title="0">{
                        LogError("load: 包%d - 错误: %v", i+1, p.Errors)
                }</span>
        }

        // 对于主包（command-line-arguments），手动设置Module信息
        <span class="cov0" title="0">for _, p := range packs </span><span class="cov0" title="0">{
                if p.PkgPath == entryPackageName &amp;&amp; p.Module == nil </span><span class="cov0" title="0">{
                        LogDebug("load: 为主包设置Module信息")
                        module := a.parseGoModule(pkgPath)
                        if module == nil </span><span class="cov0" title="0">{
                                LogError("load: 解析go.mod失败")
                                panic("failed to parse go.mod file in " + pkgPath)</span>
                        }
                        <span class="cov0" title="0">LogDebug("load: 解析go.mod成功，模块路径: %s", module.Path)
                        p.Module = module
                        p.ID = module.Path
                        LogDebug("load: 主包Module信息设置完成")</span>
                }
        }

        <span class="cov0" title="0">LogDebug("load: 包加载完成，返回包组")
        return [][]*packages.Package{packs}</span>
}

func (a *Analyzer) processFile(ctx *Context, file *ast.File, pkg *packages.Package) <span class="cov0" title="0">{
        comment := ctx.ParseComment(file.Doc)
        if comment.Ignore() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">ctx.commentStack.comment = comment

        ast.Inspect(file, func(node ast.Node) bool </span><span class="cov0" title="0">{
                switch node := node.(type) </span>{
                case *ast.FuncDecl:<span class="cov0" title="0">
                        a.funDecl(ctx.Block(), node, file, pkg)
                        return false</span>
                case *ast.BlockStmt:<span class="cov0" title="0">
                        a.blockStmt(ctx.Block(), node, file, pkg)
                        return false</span>
                }

                <span class="cov0" title="0">a.analyze(ctx, node)
                return true</span>
        })
}

func (a *Analyzer) funDecl(ctx *Context, node *ast.FuncDecl, file *ast.File, pkg *packages.Package) <span class="cov0" title="0">{
        comment := ctx.ParseComment(node.Doc)
        if comment.Ignore() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">ctx.commentStack.comment = comment

        ast.Inspect(node, func(node ast.Node) bool </span><span class="cov0" title="0">{
                switch node := node.(type) </span>{
                case *ast.BlockStmt:<span class="cov0" title="0">
                        a.blockStmt(ctx.Block(), node, file, pkg)
                        return false</span>
                }

                <span class="cov0" title="0">a.analyze(ctx, node)
                return true</span>
        })
}

func (a *Analyzer) loadDefinitionsFromPkg(pkg *packages.Package, moduleDir string) <span class="cov0" title="0">{
        LogDebug("loadDefinitionsFromPkg: 开始加载包定义: %s", pkg.PkgPath)

        // 使用defer来捕获可能的panic
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        LogError("loadDefinitionsFromPkg: 发生panic: %v", r)
                        panic(r)</span> // 重新抛出panic
                }
        }()

        <span class="cov0" title="0">var visited = make(map[string]struct{})
        InspectPackage(pkg, func(pkg *packages.Package) bool </span><span class="cov0" title="0">{
                LogDebug("loadDefinitionsFromPkg: 检查包: %s", pkg.PkgPath)
                if _, ok := visited[pkg.PkgPath]; ok </span><span class="cov0" title="0">{
                        LogDebug("loadDefinitionsFromPkg: 包已访问，跳过: %s", pkg.PkgPath)
                        return false
                }</span>
                <span class="cov0" title="0">visited[pkg.PkgPath] = struct{}{}

                if pkg.Module == nil </span><span class="cov0" title="0">{ // Go 内置包
                        LogDebug("loadDefinitionsFromPkg: Go内置包，检查依赖: %s", pkg.PkgPath)
                        ignore := true
                        for _, depend := range a.depends </span><span class="cov0" title="0">{
                                if strings.HasPrefix(pkg.PkgPath, depend) </span><span class="cov0" title="0">{
                                        ignore = false
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if ignore </span><span class="cov0" title="0">{
                                LogDebug("loadDefinitionsFromPkg: 内置包不在依赖中，跳过: %s", pkg.PkgPath)
                                return false
                        }</span>
                        <span class="cov0" title="0">LogDebug("loadDefinitionsFromPkg: 内置包在依赖中，继续处理: %s", pkg.PkgPath)</span>
                } else<span class="cov0" title="0"> {
                        LogDebug("loadDefinitionsFromPkg: 检查模块目录匹配: %s (模块目录: %s, 期望: %s)", pkg.PkgPath, pkg.Module.Dir, moduleDir)
                        if pkg.Module.Dir != moduleDir &amp;&amp; !lo.Contains(a.depends, pkg.Module.Path) </span><span class="cov0" title="0">{
                                LogDebug("loadDefinitionsFromPkg: 模块目录不匹配且不在依赖中，跳过: %s", pkg.PkgPath)
                                return false
                        }</span>
                        <span class="cov0" title="0">LogDebug("loadDefinitionsFromPkg: 模块检查通过，继续处理: %s", pkg.PkgPath)</span>
                }

                <span class="cov0" title="0">LogDebug("loadDefinitionsFromPkg: 开始处理包的语法文件，共%d个文件: %s", len(pkg.Syntax), pkg.PkgPath)
                for fileIdx, file := range pkg.Syntax </span><span class="cov0" title="0">{
                        LogDebug("loadDefinitionsFromPkg: 处理第%d个文件", fileIdx+1)
                        ast.Inspect(file, func(node ast.Node) bool </span><span class="cov0" title="0">{
                                switch node := node.(type) </span>{
                                case *ast.FuncDecl:<span class="cov0" title="0">
                                        LogDebug("loadDefinitionsFromPkg: 找到函数定义: %s", node.Name.Name)
                                        a.definitions.Set(NewFuncDefinition(pkg, file, node))
                                        return false</span>
                                case *ast.TypeSpec:<span class="cov0" title="0">
                                        LogDebug("loadDefinitionsFromPkg: 找到类型定义: %s", node.Name.Name)
                                        a.definitions.Set(NewTypeDefinition(pkg, file, node))
                                        return false</span>
                                case *ast.GenDecl:<span class="cov0" title="0">
                                        if node.Tok == token.CONST </span><span class="cov0" title="0">{
                                                LogDebug("loadDefinitionsFromPkg: 找到常量定义")
                                                a.loadEnumDefinition(pkg, file, node)
                                                return false
                                        }</span>
                                        <span class="cov0" title="0">return true</span>
                                }
                                <span class="cov0" title="0">return true</span>
                        })
                        <span class="cov0" title="0">LogDebug("loadDefinitionsFromPkg: 完成第%d个文件处理", fileIdx+1)</span>
                }
                <span class="cov0" title="0">LogDebug("loadDefinitionsFromPkg: 完成包处理: %s", pkg.PkgPath)
                return true</span>
        })
        <span class="cov0" title="0">LogDebug("loadDefinitionsFromPkg: 包定义加载完成: %s", pkg.PkgPath)</span>
}

type A int

const (
        A1 A = iota + 1
        A2
        A3
)

func (a *Analyzer) loadEnumDefinition(pkg *packages.Package, file *ast.File, node *ast.GenDecl) <span class="cov0" title="0">{
        for _, item := range node.Specs </span><span class="cov0" title="0">{
                valueSpec, ok := item.(*ast.ValueSpec)
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">for _, name := range valueSpec.Names </span><span class="cov0" title="0">{
                        c := pkg.TypesInfo.ObjectOf(name).(*types.Const)
                        t, ok := c.Type().(*types.Named)
                        if !ok </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">basicType, ok := t.Underlying().(*types.Basic)
                        if !ok </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">pkgPath := t.Obj().Pkg().Path()
                        if pkgPath != pkg.PkgPath </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">def := a.definitions.Get(t.Obj().Pkg().Path() + "." + t.Obj().Name())
                        if def == nil </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">typeDef := def.(*TypeDefinition)
                        value := ConvertStrToBasicType(c.Val().ExactString(), basicType)
                        enumItem := spec.NewExtendEnumItem(name.Name, value, strings.TrimSpace(valueSpec.Doc.Text()))
                        typeDef.Enums = append(typeDef.Enums, enumItem)</span>
                }
        }
}

func (a *Analyzer) blockStmt(ctx *Context, node *ast.BlockStmt, file *ast.File, pkg *packages.Package) <span class="cov0" title="0">{
        comment := ctx.ParseComment(a.context().WithPackage(pkg).WithFile(file).GetHeadingCommentOf(node.Lbrace))
        if comment.Ignore() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">ctx.commentStack.comment = comment

        a.analyze(ctx, node)

        for _, node := range node.List </span><span class="cov0" title="0">{
                ast.Inspect(node, func(node ast.Node) bool </span><span class="cov0" title="0">{
                        switch node := node.(type) </span>{
                        case *ast.BlockStmt:<span class="cov0" title="0">
                                a.blockStmt(ctx.Block(), node, file, pkg)
                                return false</span>
                        }

                        <span class="cov0" title="0">a.analyze(ctx, node)
                        return true</span>
                })
        }
}

func (a *Analyzer) parseGoModule(pkgPath string) *packages.Module <span class="cov0" title="0">{
        dir, fileName := a.lookupGoModFile(pkgPath)
        if fileName == "" </span><span class="cov0" title="0">{
                panic("go.mod not found in " + pkgPath)</span>
        }

        <span class="cov0" title="0">content, err := os.ReadFile(fileName)
        if err != nil </span><span class="cov0" title="0">{
                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">panic(err)</span>
        }

        <span class="cov0" title="0">mod, err := modfile.Parse("go.mod", content, nil)
        if err != nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("parse go.mod failed. %s. err=%s", fileName, err.Error()))</span>
        }

        <span class="cov0" title="0">return &amp;packages.Module{
                Path:      mod.Module.Mod.Path,
                Main:      true,
                Dir:       dir,
                GoMod:     fileName,
                GoVersion: mod.Go.Version,
        }</span>
}

func (a *Analyzer) lookupGoModFile(pkgPath string) (string, string) <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                fileName := filepath.Join(pkgPath, "go.mod")
                _, err := os.Stat(fileName)
                if err == nil </span><span class="cov0" title="0">{
                        return strings.TrimSuffix(pkgPath, string(filepath.Separator)), fileName
                }</span>
                <span class="cov0" title="0">var suffix string
                pkgPath, suffix = filepath.Split(pkgPath)
                if suffix == "" </span><span class="cov0" title="0">{
                        break</span>
                }
        }

        <span class="cov0" title="0">return "", ""</span>
}

func (a *Analyzer) context() *Context <span class="cov0" title="0">{
        return newContext(a, a.globalEnv)
}</span>

func (a *Analyzer) AddRoutes(items ...*API) <span class="cov0" title="0">{
        a.routes.add(items...)

        for _, item := range items </span><span class="cov0" title="0">{
                path := a.doc.Paths[item.FullPath]
                if path == nil </span><span class="cov0" title="0">{
                        path = &amp;spec.PathItem{}
                }</span>
                <span class="cov0" title="0">item.applyToPathItem(path)
                a.doc.Paths[item.FullPath] = path</span>
        }
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package eapi

import (
        "fmt"
        "go/ast"
        "go/token"
        "os"
        "strings"

        "github.com/chenwei67/eapi/annotation"
        "github.com/chenwei67/eapi/spec"
        "github.com/samber/lo"
)

type Comment struct {
        text        string
        Annotations []annotation.Annotation
}

func (c *Comment) Text() string <span class="cov0" title="0">{
        if c == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return c.text</span>
}

func (c *Comment) TextPointer() *string <span class="cov0" title="0">{
        if c == nil || c.Text() == "" </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return &amp;c.text</span>
}

// TrimPrefix trim comment prefix and return trimmed string
func (c *Comment) TrimPrefix(prefix string) string <span class="cov0" title="0">{
        if c == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return strings.TrimPrefix(c.text, prefix)</span>
}

func (c *Comment) Required() bool <span class="cov0" title="0">{
        if c == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">for _, a := range c.Annotations </span><span class="cov0" title="0">{
                if a.Type() == annotation.Required </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func (c *Comment) Deprecated() bool <span class="cov0" title="0">{
        if c == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">for _, a := range c.Annotations </span><span class="cov0" title="0">{
                if a.Type() == annotation.Deprecated </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func (c *Comment) ApplyToSchema(schema *spec.SchemaRef) <span class="cov0" title="0">{
        if c == nil || schema == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if schema.Ref != "" </span><span class="cov0" title="0">{
                schema.Description = c.Text()
                schema.Summary = c.Summary()
                return
        }</span>

        <span class="cov0" title="0">value := schema
        if value == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">value.Description = c.Text()
        value.Deprecated = c.Deprecated()</span>
}

func (c *Comment) Consumes() []string <span class="cov0" title="0">{
        var res []string
        for _, annot := range c.Annotations </span><span class="cov0" title="0">{
                consume, ok := annot.(*annotation.ConsumeAnnotation)
                if ok </span><span class="cov0" title="0">{
                        res = append(res, consume.ContentType)
                }</span>
        }
        <span class="cov0" title="0">return res</span>
}

func (c *Comment) Produces() []string <span class="cov0" title="0">{
        var res []string
        for _, annot := range c.Annotations </span><span class="cov0" title="0">{
                produce, ok := annot.(*annotation.ProduceAnnotation)
                if ok </span><span class="cov0" title="0">{
                        res = append(res, produce.ContentType)
                }</span>
        }
        <span class="cov0" title="0">return lo.Uniq(res)</span>
}

func (c *Comment) Tags() []string <span class="cov0" title="0">{
        if c == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var res []string
        for _, annot := range c.Annotations </span><span class="cov0" title="0">{
                tags, ok := annot.(*annotation.TagAnnotation)
                if ok </span><span class="cov0" title="0">{
                        res = append(res, tags.Tag)
                }</span>
        }
        <span class="cov0" title="0">return res</span>
}

func (c *Comment) Ignore() bool <span class="cov0" title="0">{
        if c == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">for _, annot := range c.Annotations </span><span class="cov0" title="0">{
                if annot.Type() == annotation.Ignore </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func (c *Comment) Summary() string <span class="cov0" title="0">{
        if c == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">for _, annot := range c.Annotations </span><span class="cov0" title="0">{
                summary, ok := annot.(*annotation.SummaryAnnotation)
                if ok </span><span class="cov0" title="0">{
                        return strings.TrimSpace(summary.Text)
                }</span>
        }
        <span class="cov0" title="0">return ""</span>
}

func (c *Comment) ID() string <span class="cov0" title="0">{
        if c == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">for _, annot := range c.Annotations </span><span class="cov0" title="0">{
                id, ok := annot.(*annotation.IdAnnotation)
                if ok </span><span class="cov0" title="0">{
                        return strings.TrimSpace(id.Text)
                }</span>
        }
        <span class="cov0" title="0">return ""</span>
}

func (c *Comment) Security() *spec.SecurityRequirements <span class="cov0" title="0">{
        if c == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return convertSecAnnotationToSecurityRequirements(c.Annotations)</span>
}

func convertSecAnnotationToSecurityRequirements(annotations []annotation.Annotation) *spec.SecurityRequirements <span class="cov0" title="0">{
        ret := spec.NewSecurityRequirements()
        for _, annot := range annotations </span><span class="cov0" title="0">{
                annot, ok := annot.(*annotation.SecurityAnnotation)
                if ok </span><span class="cov0" title="0">{
                        ret.With(spec.NewSecurityRequirement().Authenticate(annot.Name, annot.Params...))
                }</span>
        }
        <span class="cov0" title="0">if len(*ret) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return ret</span>
}

func ParseComment(commentGroup *ast.CommentGroup, fSet *token.FileSet) *Comment <span class="cov0" title="0">{
        return ParseCommentWithContext(commentGroup, fSet, nil)
}</span>

func ParseCommentWithContext(commentGroup *ast.CommentGroup, fSet *token.FileSet, ctx *Context) *Comment <span class="cov0" title="0">{
        if commentGroup == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">c := &amp;Comment{}
        var lines []string
        var descriptions []*annotation.DescriptionAnnotation
        for _, comment := range commentGroup.List </span><span class="cov0" title="0">{
                annot, err := annotation.NewParser(comment.Text).Parse()
                if err != nil </span><span class="cov0" title="0">{
                        err := err.(*annotation.ParseError)
                        errorMsg := fmt.Sprintf("[Invalid Annotation]: %s at %s", err, fSet.Position(comment.Pos()+token.Pos(err.Column)).String())
                        if ctx != nil </span><span class="cov0" title="0">{
                                ctx.StrictError(errorMsg)
                        }</span> else<span class="cov0" title="0"> {
                                fmt.Fprintf(os.Stderr, errorMsg+"\n")
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }
                <span class="cov0" title="0">if annot != nil </span><span class="cov0" title="0">{
                        c.Annotations = append(c.Annotations, annot)
                        desc, ok := annot.(*annotation.DescriptionAnnotation)
                        if ok </span><span class="cov0" title="0">{
                                descriptions = append(descriptions, desc)
                        }</span>
                } else<span class="cov0" title="0"> {
                        line := strings.TrimPrefix(comment.Text, "//")
                        lines = append(lines, strings.TrimSpace(line))
                }</span>
        }

        <span class="cov0" title="0">if len(descriptions) &gt; 0 </span><span class="cov0" title="0">{
                // 如果写了 @description 注解，则忽略普通注释文本
                lines = lo.Map(descriptions, func(t *annotation.DescriptionAnnotation, i int) string </span><span class="cov0" title="0">{ return t.Text }</span>)
        }
        <span class="cov0" title="0">c.text = strings.Join(lines, "\n\n")
        return c</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package eapi

import (
        "fmt"
        "go/ast"
        "go/token"
        "go/types"
        "strconv"

        "github.com/chenwei67/eapi/spec"
        "github.com/chenwei67/eapi/utils"
        "golang.org/x/tools/go/packages"
)

type RouteAnalyzer func(ctx *Context, node ast.Node) (routes []*API)

type Context struct {
        Env *Environment

        pkg          *packages.Package
        file         *ast.File
        analyzer     *Analyzer
        commentStack *CommentStack
}

func newContext(analyzer *Analyzer, env *Environment) *Context <span class="cov0" title="0">{
        return &amp;Context{
                Env:      env,
                analyzer: analyzer,
        }
}</span>

func (c *Context) WithPackage(pkg *packages.Package) *Context <span class="cov0" title="0">{
        res := *c
        res.pkg = pkg
        return &amp;res
}</span>

func (c *Context) WithFile(file *ast.File) *Context <span class="cov0" title="0">{
        res := *c
        res.file = file
        return &amp;res
}</span>

func (c *Context) Block() *Context <span class="cov0" title="0">{
        res := *c
        res.Env = NewEnvironment(c.Env)
        res.commentStack = NewCommentStack(c.commentStack, nil)
        return &amp;res
}</span>

func (c *Context) CommentStack() *CommentStack <span class="cov0" title="0">{
        return c.commentStack
}</span>

func (c *Context) Package() *packages.Package <span class="cov8" title="1">{
        return c.pkg
}</span>

func (c *Context) File() *ast.File <span class="cov0" title="0">{
        return c.file
}</span>

func (c *Context) LineColumn(pos token.Pos) string <span class="cov0" title="0">{
        return c.pkg.Fset.Position(pos).String()
}</span>

func (c *Context) GetDefinition(pkg, name string) Definition <span class="cov0" title="0">{
        return c.analyzer.definitions[pkg+"."+name]
}</span>

func (c *Context) ParseType(t types.Type) Definition <span class="cov0" title="0">{
        switch t := t.(type) </span>{
        case *types.Pointer:<span class="cov0" title="0">
                return c.ParseType(t.Elem())</span>
        case *types.Named:<span class="cov0" title="0">
                if t.Obj().Pkg() == nil </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">return c.GetDefinition(t.Obj().Pkg().Path(), t.Obj().Name())</span>
        case types.Object:<span class="cov0" title="0">
                return c.GetDefinition(t.Pkg().Path(), t.Name())</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (c *Context) Doc() *spec.T <span class="cov0" title="0">{
        return c.analyzer.Doc()
}</span>

func (c *Context) AddAPI(items ...*API) <span class="cov0" title="0">{
        c.analyzer.AddRoutes(items...)
}</span>

func (c *Context) ParseStatusCode(status ast.Expr) int <span class="cov0" title="0">{
        switch status := status.(type) </span>{
        case *ast.SelectorExpr:<span class="cov0" title="0">
                return c.ParseStatusCode(status.Sel)</span>
        case *ast.Ident:<span class="cov0" title="0">
                obj := c.pkg.TypesInfo.Uses[status]
                if obj == nil </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">objConst, ok := obj.(*types.Const)
                if !ok </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">statusCode, err := strconv.ParseInt(objConst.Val().String(), 10, 64)
                if err != nil </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">return int(statusCode)</span>

        case *ast.BasicLit:<span class="cov0" title="0">
                code, err := strconv.ParseInt(status.Value, 10, 64)
                if err != nil </span><span class="cov0" title="0">{
                        LogWarn("unknown status code '%s' at %s", status.Value, c.LineColumn(status.Pos()))
                        break</span>
                }
                <span class="cov0" title="0">return int(code)</span>

        default:<span class="cov0" title="0">
                // unknown status code
                LogWarn("unknown status code %s", c.LineColumn(status.Pos()))</span>
        }

        // unknown status code
        <span class="cov0" title="0">LogWarn("unknown status code %s", c.LineColumn(status.Pos()))

        // fallback to 200
        return 200</span>
}

func (c *Context) GetSchemaByExpr(expr ast.Expr, contentType string) *spec.SchemaRef <span class="cov0" title="0">{
        return NewSchemaBuilder(c, contentType).ParseExpr(expr)
}</span>

func (c *Context) GetHeadingCommentOf(pos token.Pos) *ast.CommentGroup <span class="cov0" title="0">{
        if c.File() == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">position := c.Package().Fset.Position(pos)
        for _, commentGroup := range c.File().Comments </span><span class="cov0" title="0">{
                start := c.Package().Fset.Position(commentGroup.Pos())
                end := c.Package().Fset.Position(commentGroup.End())
                if end.Line == position.Line-1 &amp;&amp; start.Column &lt;= position.Column </span><span class="cov0" title="0">{
                        return commentGroup
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (c *Context) GetTrailingCommentOf(pos token.Pos) *ast.CommentGroup <span class="cov0" title="0">{
        if c.File() == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">position := c.Package().Fset.Position(pos)
        for _, commentGroup := range c.File().Comments </span><span class="cov0" title="0">{
                commentPos := c.Package().Fset.Position(commentGroup.End())
                if commentPos.Line == position.Line </span><span class="cov0" title="0">{
                        return commentGroup
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (c *Context) APIs() *APIs <span class="cov0" title="0">{
        return c.analyzer.APIs()
}</span>

func (c *Context) NewEnv() *Context <span class="cov0" title="0">{
        res := *c
        res.Env = NewEnvironment(nil)
        return &amp;res
}</span>

// StrictError prints red error message in strict mode, otherwise prints to stderr
func (c *Context) StrictError(format string, args ...interface{}) <span class="cov0" title="0">{
        LogStrictError(format, args...)
}</span>

// StrictWarn prints yellow warning message in strict mode, otherwise prints to stderr
func (c *Context) StrictWarn(format string, args ...interface{}) <span class="cov0" title="0">{
        LogStrictWarn(format, args...)
}</span>

type CallRule struct {
        Rules map[string][]string // typeName to function-names
}

func NewCallRule() *CallRule <span class="cov0" title="0">{
        r := new(CallRule)
        r.Rules = make(map[string][]string)
        return r
}</span>

func (c *CallRule) WithRule(typeName string, fnNames ...string) *CallRule <span class="cov0" title="0">{
        c.Rules[typeName] = append(c.Rules[typeName], fnNames...)
        return c
}</span>

func (c *Context) MatchCall(n ast.Node, rule *CallRule, callback func(call *ast.CallExpr, typeName, fnName string)) <span class="cov0" title="0">{
        callExpr, ok := n.(*ast.CallExpr)
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">actualTypeName, actualFnName, err := c.GetCallInfo(callExpr)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">for typeName, fnNames := range rule.Rules </span><span class="cov0" title="0">{
                for _, fnName := range fnNames </span><span class="cov0" title="0">{
                        if typeName == actualTypeName &amp;&amp; fnName == actualFnName </span><span class="cov0" title="0">{
                                callback(callExpr, typeName, fnName)
                        }</span>
                }
        }

        <span class="cov0" title="0">return</span>
}

func (c *Context) GetFuncFromAstNode(n ast.Node) *types.Func <span class="cov0" title="0">{
        var obj interface{}
        switch handlerArg := n.(type) </span>{
        case *ast.Ident:<span class="cov0" title="0">
                obj = c.Package().TypesInfo.ObjectOf(handlerArg)</span>
        case *ast.SelectorExpr:<span class="cov0" title="0">
                obj = c.Package().TypesInfo.ObjectOf(handlerArg.Sel)</span>
        default:<span class="cov0" title="0">
                return nil</span>
        }
        <span class="cov0" title="0">fn, ok := obj.(*types.Func)
        if !ok </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return fn</span>
}

type CallInfo struct {
        Type   string
        Method string
}

// GetCallInfo returns the package or type and name associated with a call expression
//
// e.g. GetCallInfo(`c.GET("/ping", ...)`) returns ("*github/gin-gonic/gin.RouterGroup", "GET", nil)
func (c *Context) GetCallInfo(n ast.Node) (string, string, error) <span class="cov8" title="1">{
        switch node := n.(type) </span>{
        case *ast.CallExpr:<span class="cov8" title="1">
                switch fn := node.Fun.(type) </span>{
                case *ast.SelectorExpr:<span class="cov8" title="1">
                        // try to parse type of sel.Sel
                        info := c.parseCallInfoByIdent(fn.Sel)
                        if info != nil </span><span class="cov0" title="0">{
                                return info.Type, info.Method, nil
                        }</span>

                        <span class="cov8" title="1">switch expr := fn.X.(type) </span>{
                        case *ast.Ident:<span class="cov8" title="1">
                                if expr.Obj != nil &amp;&amp; expr.Obj.Kind == ast.Var </span><span class="cov8" title="1">{
                                        t := c.Package().TypesInfo.TypeOf(expr)
                                        if t != nil </span><span class="cov0" title="0">{
                                                return t.String(), fn.Sel.Name, nil
                                        }</span>
                                        <span class="cov8" title="1">return "undefined", fn.Sel.Name, fmt.Errorf("missing type info")</span>
                                }
                                <span class="cov8" title="1">return expr.Name, fn.Sel.Name, nil</span>
                        case *ast.SelectorExpr:<span class="cov0" title="0">
                                if expr.Sel != nil </span><span class="cov0" title="0">{
                                        t := c.Package().TypesInfo.TypeOf(expr.Sel)
                                        if t != nil </span><span class="cov0" title="0">{
                                                return t.String(), fn.Sel.Name, nil
                                        }</span>
                                        <span class="cov0" title="0">return "undefined", fn.Sel.Name, fmt.Errorf("missing type info")</span>
                                }
                        case *ast.CallExpr:<span class="cov0" title="0">
                                switch call := expr.Fun.(type) </span>{
                                case *ast.Ident:<span class="cov0" title="0">
                                        if call.Name == "new" </span><span class="cov0" title="0">{
                                                t := c.Package().TypesInfo.TypeOf(expr.Args[0])
                                                if t != nil </span><span class="cov0" title="0">{
                                                        return t.String(), fn.Sel.Name, nil
                                                }</span>
                                                <span class="cov0" title="0">return "undefined", fn.Sel.Name, fmt.Errorf("missing type info")</span>
                                        }
                                        <span class="cov0" title="0">if call.Obj != nil </span><span class="cov0" title="0">{
                                                switch decl := call.Obj.Decl.(type) </span>{
                                                case *ast.FuncDecl:<span class="cov0" title="0">
                                                        ret := decl.Type.Results
                                                        if ret != nil &amp;&amp; len(ret.List) &gt; 0 </span><span class="cov0" title="0">{
                                                                ret1 := ret.List[0]
                                                                if ret1 != nil </span><span class="cov0" title="0">{
                                                                        t := c.Package().TypesInfo.TypeOf(ret1.Type)
                                                                        if t != nil </span><span class="cov0" title="0">{
                                                                                return t.String(), fn.Sel.Name, nil
                                                                        }</span>
                                                                        <span class="cov0" title="0">return "undefined", fn.Sel.Name, fmt.Errorf("missing type info")</span>
                                                                }
                                                        }
                                                }
                                        }
                                }
                        }
                case *ast.Ident:<span class="cov8" title="1">
                        // try to parse type of sel.Sel
                        info := c.parseCallInfoByIdent(fn)
                        if info != nil </span><span class="cov0" title="0">{
                                return info.Type, info.Method, nil
                        }</span>

                        <span class="cov8" title="1">return c.Package().Name, fn.Name, nil</span>
                }
        }

        <span class="cov8" title="1">return "", "", fmt.Errorf("unable to determine call info")</span>
}

func (c *Context) parseCallInfoByIdent(ident *ast.Ident) (info *CallInfo) <span class="cov8" title="1">{
        info = &amp;CallInfo{}
        t := c.Package().TypesInfo.ObjectOf(ident)
        fn, ok := t.(*types.Func)
        if !ok </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov0" title="0">info.Type, info.Method = utils.GetFuncInfo(fn)
        return</span>
}

func (c *Context) ParseComment(commentGroup *ast.CommentGroup) *Comment <span class="cov0" title="0">{
        return ParseComment(commentGroup, c.Package().Fset)
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package eapi

import (
        "go/ast"
        "strings"

        "github.com/chenwei67/eapi/spec"
        "golang.org/x/tools/go/packages"
)

type Definition interface {
        Pkg() *packages.Package
        File() *ast.File
        Key() string

        definition()
}

var _ Definition = &amp;FuncDefinition{}

type FuncDefinition struct {
        pkg  *packages.Package
        file *ast.File

        Decl *ast.FuncDecl
}

func NewFuncDefinition(pkg *packages.Package, file *ast.File, decl *ast.FuncDecl) *FuncDefinition <span class="cov0" title="0">{
        return &amp;FuncDefinition{pkg: pkg, file: file, Decl: decl}
}</span>

func (f *FuncDefinition) Key() string <span class="cov0" title="0">{
        if f.Decl.Recv.NumFields() == 1 </span><span class="cov0" title="0">{
                receiver := f.Decl.Recv.List[0]
                switch t := receiver.Type.(type) </span>{
                case *ast.Ident:<span class="cov0" title="0">
                        return f.pkg.PkgPath + "." + t.Name + "." + f.Decl.Name.Name</span>
                case *ast.StarExpr:<span class="cov0" title="0">
                        switch i := t.X.(type) </span>{
                        case *ast.Ident:<span class="cov0" title="0">
                                return "*" + f.pkg.PkgPath + "." + i.Name + "." + f.Decl.Name.Name</span>
                        case *ast.IndexExpr:<span class="cov0" title="0">
                                // 范型未被完全支持，暂时先这样处理
                                _i, ok := i.X.(*ast.Ident)
                                if !ok </span><span class="cov0" title="0">{
                                        return ""
                                }</span>
                                <span class="cov0" title="0">return "*" + f.pkg.PkgPath + "." + _i.Name + "." + f.Decl.Name.Name</span>
                        default:<span class="cov0" title="0">
                                LogWarn("invalid function receiver at %s", f.pkg.Fset.Position(receiver.Pos()).String())</span>
                        }
                case *ast.IndexExpr:<span class="cov0" title="0">
                        // 范型未被完全支持，暂时先这样处理
                        return ""</span>
                default:<span class="cov0" title="0">
                        LogWarn("invalid function receiver at %s", f.pkg.Fset.Position(receiver.Pos()).String())</span>
                }
        }

        <span class="cov0" title="0">return f.pkg.PkgPath + "." + f.Decl.Name.Name</span>
}

func (f *FuncDefinition) Pkg() *packages.Package <span class="cov0" title="0">{
        return f.pkg
}</span>

func (f *FuncDefinition) File() *ast.File <span class="cov0" title="0">{
        return f.file
}</span>

func (f *FuncDefinition) definition() {<span class="cov0" title="0">}</span>

var _ Definition = &amp;TypeDefinition{}

type TypeDefinition struct {
        Spec *ast.TypeSpec

        // Enum items
        Enums []*spec.ExtendedEnumItem

        pkg  *packages.Package
        file *ast.File
}

func NewTypeDefinition(pkg *packages.Package, file *ast.File, spec *ast.TypeSpec) *TypeDefinition <span class="cov0" title="0">{
        return &amp;TypeDefinition{pkg: pkg, file: file, Spec: spec}
}</span>

func (t *TypeDefinition) definition() {<span class="cov0" title="0">}</span>

func (t *TypeDefinition) Pkg() *packages.Package <span class="cov0" title="0">{
        return t.pkg
}</span>

func (t *TypeDefinition) File() *ast.File <span class="cov0" title="0">{
        return t.file
}</span>

func (t *TypeDefinition) Key() string <span class="cov0" title="0">{
        return t.pkg.PkgPath + "." + t.Spec.Name.Name
}</span>

func (t *TypeDefinition) ModelKey(typeArgs ...*spec.SchemaRef) string <span class="cov0" title="0">{
        sb := strings.Builder{}
        sb.WriteString(strings.ReplaceAll(t.pkg.PkgPath, "/", "_"))
        sb.WriteString(".")
        sb.WriteString(t.Spec.Name.Name)
        if len(typeArgs) &gt; 0 </span><span class="cov0" title="0">{
                sb.WriteString("[")
                sb.WriteString(typeArgs[0].GetKey())
                for _, arg := range typeArgs[1:] </span><span class="cov0" title="0">{
                        sb.WriteString(",")
                        sb.WriteString(arg.GetKey())
                }</span>
                <span class="cov0" title="0">sb.WriteString("]")</span>
        }
        <span class="cov0" title="0">return sb.String()</span>
}

func (t *TypeDefinition) RefKey(typeArgs ...*spec.SchemaRef) string <span class="cov0" title="0">{
        return "#/components/schemas/" + t.ModelKey(typeArgs...)
}</span>

type Definitions map[string]Definition

func (d *Definitions) Set(def Definition) <span class="cov0" title="0">{
        k := def.Key()
        if k != "" </span><span class="cov0" title="0">{
                (*d)[k] = def
        }</span>
}

func (d *Definitions) Get(key string) Definition <span class="cov0" title="0">{
        return (*d)[key]
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package eapi

import (
        "encoding/json"
        "fmt"
        "io/fs"
        "os"
        "path/filepath"
        "runtime/debug"

        "github.com/chenwei67/eapi/spec"
        "github.com/knadh/koanf"
        "github.com/knadh/koanf/parsers/yaml"
        "github.com/knadh/koanf/providers/file"
        "github.com/urfave/cli/v2"
)

type Config struct {
        Plugin     string
        Dir        string
        Output     string
        Depends    []string
        StrictMode bool
        LogLevel   string `yaml:"logLevel"`
        OpenAPI    OpenAPIConfig

        Generators []*GeneratorConfig
}

type OpenAPIConfig struct {
        OpenAPI         string           `yaml:"openapi"` // OpenAPI version 3.0.0|3.0.3|3.1.0
        Info            *spec.Info       `yaml:"info"`    // Required
        SecuritySchemes *SecuritySchemes `yaml:"securitySchemes"`
}

type SecuritySchemes map[string]*spec.SecurityScheme

func (c OpenAPIConfig) ApplyToDoc(doc *spec.T) <span class="cov0" title="0">{
        if c.OpenAPI != "" </span><span class="cov0" title="0">{
                doc.OpenAPI = c.OpenAPI
        }</span>
        <span class="cov0" title="0">if c.Info != nil </span><span class="cov0" title="0">{
                if c.Info.Version != "" </span><span class="cov0" title="0">{
                        doc.Info.Version = c.Info.Version
                }</span>
                <span class="cov0" title="0">if c.Info.Title != "" </span><span class="cov0" title="0">{
                        doc.Info.Title = c.Info.Title
                }</span>
                <span class="cov0" title="0">if c.Info.Description != "" </span><span class="cov0" title="0">{
                        doc.Info.Description = c.Info.Description
                }</span>
                <span class="cov0" title="0">if c.Info.TermsOfService != "" </span><span class="cov0" title="0">{
                        doc.Info.TermsOfService = c.Info.TermsOfService
                }</span>
        }
        <span class="cov0" title="0">if c.SecuritySchemes != nil </span><span class="cov0" title="0">{
                doc.Components.SecuritySchemes = make(map[string]*spec.SecuritySchemeRef)
                for name, scheme := range *c.SecuritySchemes </span><span class="cov0" title="0">{
                        doc.Components.SecuritySchemes[name] = &amp;spec.SecuritySchemeRef{Value: scheme}
                }</span>
        }
}

type GeneratorConfig struct {
        Name   string
        File   string
        Output string
}

type Entrypoint struct {
        k       *koanf.Koanf
        plugins []Plugin

        cfg Config
}

func NewEntrypoint(plugins ...Plugin) *Entrypoint <span class="cov0" title="0">{
        return &amp;Entrypoint{
                k:       koanf.New("."),
                plugins: plugins,
                cfg: Config{
                        Plugin:   "gin",
                        Dir:      ".",
                        Output:   "docs",
                        LogLevel: "info",
                },
        }
}</span>

const usageText = `Generate Doc:
        eapi --config config.yaml
or
        eapi --plugin gin --dir src/ --output docs/

Generate Frontend Code:
        eapi --config config.yaml gencode
or
        eapi --plugin gin --dir src/ --output docs/ gencode`

func (e *Entrypoint) Run(args []string) <span class="cov0" title="0">{
        app := cli.NewApp()
        app.Name = "egen"
        app.Usage = `Tool for generating OpenAPI documentation and Frontend Code by static-analysis`
        app.UsageText = usageText
        app.Description = `Tool for generating OpenAPI documentation and Frontend Code by static-analysis`
        app.Flags = append(app.Flags, &amp;cli.StringFlag{
                Name:        "plugin",
                Aliases:     []string{"p", "plug"},
                Usage:       "specify plugin name",
                Destination: &amp;e.cfg.Plugin,
        })
        app.Flags = append(app.Flags, &amp;cli.StringFlag{
                Name:        "dir",
                Aliases:     []string{"d"},
                Usage:       "directory of your project which contains go.mod file",
                Destination: &amp;e.cfg.Dir,
        })
        app.Flags = append(app.Flags, &amp;cli.StringFlag{
                Name:        "output",
                Aliases:     []string{"o"},
                Usage:       "output directory of openapi.json",
                Destination: &amp;e.cfg.Output,
        })
        app.Flags = append(app.Flags, &amp;cli.StringSliceFlag{
                Name:    "depends",
                Aliases: []string{"dep"},
                Usage:   "depended module name",
                Action: func(context *cli.Context, depends []string) error </span><span class="cov0" title="0">{
                        e.cfg.Depends = depends
                        return nil
                }</span>,
        })
        <span class="cov0" title="0">app.Flags = append(app.Flags, &amp;cli.StringFlag{
                Name:     "config",
                Aliases:  []string{"c"},
                Usage:    "configuration file",
                Required: false,
        })
        app.Flags = append(app.Flags, &amp;cli.BoolFlag{
                Name:        "strict",
                Aliases:     []string{"s"},
                Usage:       "enable strict mode - show red error logs instead of skipping issues",
                Destination: &amp;e.cfg.StrictMode,
        })
        app.Flags = append(app.Flags, &amp;cli.StringFlag{
                Name:        "log-level",
                Aliases:     []string{"l"},
                Usage:       "set log level (silent, error, warn, info, debug)",
                Value:       "info",
                Destination: &amp;e.cfg.LogLevel,
        })

        app.Commands = append(app.Commands, showVersion())

        app.Action = e.run

        err := app.Run(args)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println(err.Error())
                os.Exit(1)
        }</span>
}

func (e *Entrypoint) before(c *cli.Context) error <span class="cov0" title="0">{
        cfg := c.String("config")
        if cfg == "" </span><span class="cov0" title="0">{
                fileInfo, err := os.Stat("eapi.yaml")
                if err == nil &amp;&amp; !fileInfo.IsDir() </span><span class="cov0" title="0">{
                        cfg = "eapi.yaml"
                }</span>
        }
        <span class="cov0" title="0">if cfg != "" </span><span class="cov0" title="0">{
                err := e.loadConfig(cfg)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">err = e.k.Unmarshal("", &amp;e.cfg)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">if e.cfg.Plugin == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("'plugin' is not set")
        }</span>
        <span class="cov0" title="0">if e.cfg.Dir == "" </span><span class="cov0" title="0">{
                e.cfg.Dir = "."
        }</span>
        <span class="cov0" title="0">if e.cfg.Output == "" </span><span class="cov0" title="0">{
                e.cfg.Output = "docs"
        }</span>

        // Initialize global logger
        <span class="cov0" title="0">logLevel := ParseLogLevel(e.cfg.LogLevel)
        SetGlobalLogLevel(logLevel)
        SetGlobalLogStrictMode(e.cfg.StrictMode)

        return nil</span>
}

func (e *Entrypoint) loadConfig(cfg string) error <span class="cov0" title="0">{
        return e.k.Load(file.Provider(cfg), yaml.Parser())
}</span>

func (e *Entrypoint) run(c *cli.Context) error <span class="cov0" title="0">{
        var plugin Plugin

        err := e.before(c)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">for _, p := range e.plugins </span><span class="cov0" title="0">{
                if p.Name() == e.cfg.Plugin </span><span class="cov0" title="0">{
                        plugin = p
                        break</span>
                }
        }
        <span class="cov0" title="0">if plugin == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("plugin %s not exists", e.cfg.Plugin)
        }</span>

        <span class="cov0" title="0">stat, err := os.Stat(e.cfg.Dir)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if !stat.IsDir() </span><span class="cov0" title="0">{
                return fmt.Errorf("%s is not a directory", e.cfg.Dir)
        }</span>

        <span class="cov0" title="0">err = os.MkdirAll(e.cfg.Output, os.ModePerm)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">LogInfo("output directory: %s", e.cfg.Output)
        if e.cfg.StrictMode </span><span class="cov0" title="0">{
                LogWarn("[STRICT MODE] Enabled - errors will be reported instead of skipped")
        }</span>
        <span class="cov0" title="0">a := NewAnalyzer(e.k).Plugin(plugin).Depends(e.cfg.Depends...).WithStrictMode(e.cfg.StrictMode)
        LogDebug("doc0: 开始处理文档")

        // 获取原始文档
        LogDebug("doc0.1: 开始Process处理")
        processedAnalyzer := a.Process(e.cfg.Dir)
        LogDebug("doc0.2: Process处理完成")

        rawDoc := processedAnalyzer.Doc()
        LogDebug("doc0.3: 获取原始文档完成，开始Specialize处理")

        // 执行Specialize，这里可能出现unknown type error
        doc := rawDoc.Specialize()
        LogDebug("doc1: Specialize处理完成")
        e.cfg.OpenAPI.ApplyToDoc(doc)
        // write documentation
        </span><span class="cov0" title="0">{
                docContent, err := json.MarshalIndent(doc, "", "    ")
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("json MarshalIndent err: %s", err.Error())
                }</span>
                <span class="cov0" title="0">err = os.WriteFile(filepath.Join(e.cfg.Output, "openapi.json"), docContent, fs.ModePerm)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // execute generators
        <span class="cov0" title="0">for idx, item := range e.cfg.Generators </span><span class="cov0" title="0">{
                err = newGeneratorExecutor(
                        item,
                        doc,
                        func(key string) interface{} </span><span class="cov0" title="0">{
                                confMap := e.k.Get("generators").([]interface{})[idx].(map[string]interface{})
                                val, ok := confMap[key]
                                if !ok </span><span class="cov0" title="0">{
                                        return nil
                                }</span>
                                <span class="cov0" title="0">return val</span>
                        },
                        e.cfg.StrictMode,
                ).execute()
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func showVersion() *cli.Command <span class="cov0" title="0">{
        return &amp;cli.Command{
                Name: "version",
                Action: func(c *cli.Context) error </span><span class="cov0" title="0">{
                        info, ok := debug.ReadBuildInfo()
                        if !ok </span><span class="cov0" title="0">{
                                LogInfo("unknown version")
                                os.Exit(1)
                                return nil
                        }</span>
                        <span class="cov0" title="0">LogInfo("%s", info.Main.Version)
                        return nil</span>
                },
        }
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package eapi

import (
        "github.com/chenwei67/eapi/annotation"
        "github.com/samber/lo"
)

type Environment struct {
        parent  *Environment
        records map[interface{}]interface{}
}

func NewEnvironment(parent *Environment) *Environment <span class="cov0" title="0">{
        return &amp;Environment{parent: parent, records: make(map[interface{}]interface{})}
}</span>

func (e *Environment) Define(k, v interface{}) *Environment <span class="cov0" title="0">{
        e.records[k] = v
        return e
}</span>

func (e *Environment) Lookup(k interface{}) interface{} <span class="cov0" title="0">{
        env := e.Resolve(k)
        if env == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return env.records[k]</span>
}

func (e *Environment) Resolve(k interface{}) *Environment <span class="cov0" title="0">{
        _, ok := e.records[k]
        if ok </span><span class="cov0" title="0">{
                return e
        }</span>
        <span class="cov0" title="0">if e.parent != nil </span><span class="cov0" title="0">{
                return e.parent.Resolve(k)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (e *Environment) Assign(k, v interface{}) *Environment <span class="cov0" title="0">{
        scope := e.Resolve(k)
        if scope != nil </span><span class="cov0" title="0">{
                scope.Define(k, v)
        }</span>
        <span class="cov0" title="0">return e</span>
}

type CommentStack struct {
        parent  *CommentStack
        comment *Comment
}

func NewCommentStack(parent *CommentStack, comment *Comment) *CommentStack <span class="cov0" title="0">{
        return &amp;CommentStack{parent: parent, comment: comment}
}</span>

func (e *CommentStack) ResolveByAnnotation(annotType annotation.Type) *CommentStack <span class="cov0" title="0">{
        if e.comment != nil </span><span class="cov0" title="0">{
                for _, a := range e.comment.Annotations </span><span class="cov0" title="0">{
                        if a.Type() == annotType </span><span class="cov0" title="0">{
                                return e
                        }</span>
                }
        }
        <span class="cov0" title="0">if e.parent != nil </span><span class="cov0" title="0">{
                return e.parent.ResolveByAnnotation(annotType)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (e *CommentStack) LookupAnnotations(annotType annotation.Type) []annotation.Annotation <span class="cov0" title="0">{
        env := e.ResolveByAnnotation(annotType)
        if env == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return lo.Filter(env.comment.Annotations, func(a annotation.Annotation, i int) bool </span><span class="cov0" title="0">{
                return a.Type() == annotType
        }</span>)
}

func (e *CommentStack) LookupTags() []string <span class="cov0" title="0">{
        return lo.Map(e.LookupAnnotations(annotation.Tag), func(t annotation.Annotation, i int) string </span><span class="cov0" title="0">{
                return t.(*annotation.TagAnnotation).Tag
        }</span>)
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package eapi

import (
        "fmt"
        "os"
        "path/filepath"

        "github.com/chenwei67/eapi/generators"
        "github.com/chenwei67/eapi/spec"
)

type generatorExecutor struct {
        cfg        *GeneratorConfig
        doc        *spec.T
        getConfig  func(key string) interface{}
        strictMode bool
}

func newGeneratorExecutor(cfg *GeneratorConfig, doc *spec.T, getConfig func(key string) interface{}, strictMode bool) *generatorExecutor <span class="cov0" title="0">{
        return &amp;generatorExecutor{cfg: cfg, doc: doc, getConfig: getConfig, strictMode: strictMode}
}</span>

func (r *generatorExecutor) execute() (err error) <span class="cov0" title="0">{
        var ok bool
        item := r.cfg
        var generator *generators.Generator
        if item.File != "" </span><span class="cov0" title="0">{
                generator = generators.NewGeneratorFromFile(item.File)
        }</span> else<span class="cov0" title="0"> {
                if item.Name == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("generator name or file cannot be empty")
                }</span>
                <span class="cov0" title="0">generator, ok = generators.Generators[item.Name]
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("generator '%s' not exists", item.Name)
                }</span>
        }

        <span class="cov0" title="0">err = r.generate(generator)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">return</span>
}

func (r *generatorExecutor) generate(t *generators.Generator) error <span class="cov0" title="0">{
        errorLogger := func(format string, args ...interface{}) </span><span class="cov0" title="0">{
                LogStrictError(format, args...)
        }</span>
        <span class="cov0" title="0">result := t.Print(r.doc, &amp;generators.PrintOptions{
                GetConfig:   r.getConfig,
                StrictMode:  r.strictMode,
                ErrorLogger: errorLogger,
        })
        for _, item := range result </span><span class="cov0" title="0">{
                outputFile := filepath.Join(r.cfg.Output, item.FileName)
                dir := filepath.Dir(outputFile)
                err := os.MkdirAll(dir, os.ModePerm)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("create directory %s error: %w", dir, err)
                }</span>
                <span class="cov0" title="0">file, err := os.OpenFile(outputFile, os.O_CREATE|os.O_TRUNC|os.O_RDWR, os.ModePerm)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("open file %s error: %w", outputFile, err)
                }</span>
                <span class="cov0" title="0">_, err = file.WriteString(item.Code)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("write file %s error: %w", outputFile, err)
                }</span>
                <span class="cov0" title="0">file.Close()</span>
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package eapi

import (
        "fmt"
        "io"
        "os"
        "strings"
        "time"
)

// LogLevel represents the severity level of a log message
type LogLevel int

const (
        // LogLevelSilent suppresses all log output
        LogLevelSilent LogLevel = iota
        // LogLevelError shows only error messages
        LogLevelError
        // LogLevelWarn shows error and warning messages
        LogLevelWarn
        // LogLevelInfo shows error, warning, and info messages
        LogLevelInfo
        // LogLevelDebug shows all messages including debug information
        LogLevelDebug
)

// String returns the string representation of the log level
func (l LogLevel) String() string <span class="cov0" title="0">{
        switch l </span>{
        case LogLevelSilent:<span class="cov0" title="0">
                return "silent"</span>
        case LogLevelError:<span class="cov0" title="0">
                return "error"</span>
        case LogLevelWarn:<span class="cov0" title="0">
                return "warn"</span>
        case LogLevelInfo:<span class="cov0" title="0">
                return "info"</span>
        case LogLevelDebug:<span class="cov0" title="0">
                return "debug"</span>
        default:<span class="cov0" title="0">
                return "unknown"</span>
        }
}

// ParseLogLevel parses a string into a LogLevel
func ParseLogLevel(level string) LogLevel <span class="cov0" title="0">{
        switch strings.ToLower(level) </span>{
        case "silent":<span class="cov0" title="0">
                return LogLevelSilent</span>
        case "error":<span class="cov0" title="0">
                return LogLevelError</span>
        case "warn", "warning":<span class="cov0" title="0">
                return LogLevelWarn</span>
        case "info":<span class="cov0" title="0">
                return LogLevelInfo</span>
        case "debug":<span class="cov0" title="0">
                return LogLevelDebug</span>
        default:<span class="cov0" title="0">
                return LogLevelInfo</span> // default to info level
        }
}

// Logger provides structured logging with different levels
type Logger struct {
        level      LogLevel
        output     io.Writer
        errorOut   io.Writer
        colorized  bool
        timestamp  bool
        strictMode bool
}

// NewLogger creates a new logger with the specified level
func NewLogger(level LogLevel) *Logger <span class="cov8" title="1">{
        return &amp;Logger{
                level:     level,
                output:    os.Stdout,
                errorOut:  os.Stderr,
                colorized: true,
                timestamp: false,
        }
}</span>

// SetLevel sets the logging level
func (l *Logger) SetLevel(level LogLevel) <span class="cov0" title="0">{
        l.level = level
}</span>

// SetOutput sets the output writer for info and debug messages
func (l *Logger) SetOutput(w io.Writer) <span class="cov0" title="0">{
        l.output = w
}</span>

// SetErrorOutput sets the output writer for error and warning messages
func (l *Logger) SetErrorOutput(w io.Writer) <span class="cov0" title="0">{
        l.errorOut = w
}</span>

// SetColorized enables or disables colored output
func (l *Logger) SetColorized(colorized bool) <span class="cov0" title="0">{
        l.colorized = colorized
}</span>

// SetTimestamp enables or disables timestamp in log messages
func (l *Logger) SetTimestamp(timestamp bool) <span class="cov0" title="0">{
        l.timestamp = timestamp
}</span>

// SetStrictMode enables or disables strict mode
func (l *Logger) SetStrictMode(strict bool) <span class="cov0" title="0">{
        l.strictMode = strict
}</span>

// formatMessage formats a log message with optional timestamp and color
func (l *Logger) formatMessage(level, color, message string) string <span class="cov0" title="0">{
        var parts []string
        
        if l.timestamp </span><span class="cov0" title="0">{
                parts = append(parts, time.Now().Format("2006-01-02 15:04:05"))
        }</span>
        
        <span class="cov0" title="0">if l.colorized &amp;&amp; color != "" </span><span class="cov0" title="0">{
                parts = append(parts, fmt.Sprintf("%s[%s]\033[0m", color, level))
        }</span> else<span class="cov0" title="0"> {
                parts = append(parts, fmt.Sprintf("[%s]", level))
        }</span>
        
        <span class="cov0" title="0">parts = append(parts, message)
        return strings.Join(parts, " ")</span>
}

// Error logs an error message
func (l *Logger) Error(format string, args ...interface{}) <span class="cov0" title="0">{
        if l.level &lt; LogLevelError </span><span class="cov0" title="0">{
                return
        }</span>
        
        <span class="cov0" title="0">message := fmt.Sprintf(format, args...)
        color := "\033[31m" // red
        if l.strictMode </span><span class="cov0" title="0">{
                color = "\033[31m" // red for strict mode
        }</span>
        
        <span class="cov0" title="0">formatted := l.formatMessage("ERROR", color, message)
        fmt.Fprintln(l.errorOut, formatted)</span>
}

// Warn logs a warning message
func (l *Logger) Warn(format string, args ...interface{}) <span class="cov0" title="0">{
        if l.level &lt; LogLevelWarn </span><span class="cov0" title="0">{
                return
        }</span>
        
        <span class="cov0" title="0">message := fmt.Sprintf(format, args...)
        color := "\033[33m" // yellow
        
        formatted := l.formatMessage("WARN", color, message)
        fmt.Fprintln(l.errorOut, formatted)</span>
}

// Info logs an info message
func (l *Logger) Info(format string, args ...interface{}) <span class="cov0" title="0">{
        if l.level &lt; LogLevelInfo </span><span class="cov0" title="0">{
                return
        }</span>
        
        <span class="cov0" title="0">message := fmt.Sprintf(format, args...)
        color := "\033[36m" // cyan
        
        formatted := l.formatMessage("INFO", color, message)
        fmt.Fprintln(l.output, formatted)</span>
}

// Debug logs a debug message
func (l *Logger) Debug(format string, args ...interface{}) <span class="cov0" title="0">{
        if l.level &lt; LogLevelDebug </span><span class="cov0" title="0">{
                return
        }</span>
        
        <span class="cov0" title="0">message := fmt.Sprintf(format, args...)
        color := "\033[37m" // white
        
        formatted := l.formatMessage("DEBUG", color, message)
        fmt.Fprintln(l.output, formatted)</span>
}

// StrictError logs an error in strict mode (red) or normal mode (stderr)
func (l *Logger) StrictError(format string, args ...interface{}) <span class="cov0" title="0">{
        if l.strictMode </span><span class="cov0" title="0">{
                l.Error(format, args...)
        }</span> else<span class="cov0" title="0"> {
                message := fmt.Sprintf(format, args...)
                fmt.Fprintln(l.errorOut, message)
        }</span>
}

// StrictWarn logs a warning in strict mode (yellow) or normal mode (stderr)
func (l *Logger) StrictWarn(format string, args ...interface{}) <span class="cov0" title="0">{
        if l.strictMode </span><span class="cov0" title="0">{
                l.Warn(format, args...)
        }</span> else<span class="cov0" title="0"> {
                message := fmt.Sprintf(format, args...)
                fmt.Fprintln(l.errorOut, message)
        }</span>
}

// Global logger instance
var globalLogger = NewLogger(LogLevelInfo)

// SetGlobalLogLevel sets the global logger level
func SetGlobalLogLevel(level LogLevel) <span class="cov0" title="0">{
        globalLogger.SetLevel(level)
}</span>

// SetGlobalLogColorized sets the global logger colorization
func SetGlobalLogColorized(colorized bool) <span class="cov0" title="0">{
        globalLogger.SetColorized(colorized)
}</span>

// SetGlobalLogTimestamp sets the global logger timestamp
func SetGlobalLogTimestamp(timestamp bool) <span class="cov0" title="0">{
        globalLogger.SetTimestamp(timestamp)
}</span>

// SetGlobalLogStrictMode sets the global logger strict mode
func SetGlobalLogStrictMode(strict bool) <span class="cov0" title="0">{
        globalLogger.SetStrictMode(strict)
}</span>

// GetGlobalLogger returns the global logger instance
func GetGlobalLogger() *Logger <span class="cov0" title="0">{
        return globalLogger
}</span>

// Global logging functions
func LogError(format string, args ...interface{}) <span class="cov0" title="0">{
        globalLogger.Error(format, args...)
}</span>

func LogWarn(format string, args ...interface{}) <span class="cov0" title="0">{
        globalLogger.Warn(format, args...)
}</span>

func LogInfo(format string, args ...interface{}) <span class="cov0" title="0">{
        globalLogger.Info(format, args...)
}</span>

func LogDebug(format string, args ...interface{}) <span class="cov0" title="0">{
        globalLogger.Debug(format, args...)
}</span>

func LogStrictError(format string, args ...interface{}) <span class="cov0" title="0">{
        globalLogger.StrictError(format, args...)
}</span>

func LogStrictWarn(format string, args ...interface{}) <span class="cov0" title="0">{
        globalLogger.StrictWarn(format, args...)
}</pre>
		
		<pre class="file" id="file8" style="display: none">package eapi

import (
        "golang.org/x/mod/modfile"
        "golang.org/x/mod/module"
)

type ModFile struct {
        *modfile.File
}

func LoadModFileFrom(packagePath string) (mod *ModFile, err error) <span class="cov0" title="0">{
        file, err := ReadGoMod(packagePath)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">mod = &amp;ModFile{File: file}
        return</span>
}

func (m *ModFile) GetDep(moduleName string) *module.Version <span class="cov0" title="0">{
        // check if is replaced
        for _, replace := range m.Replace </span><span class="cov0" title="0">{
                if replace.Old.Path == moduleName </span><span class="cov0" title="0">{
                        return &amp;replace.New
                }</span>
        }

        <span class="cov0" title="0">for _, require := range m.Require </span><span class="cov0" title="0">{
                if require.Mod.Path == moduleName </span><span class="cov0" title="0">{
                        return &amp;require.Mod
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package eapi

import (
        "go/ast"
        "go/types"

        "github.com/chenwei67/eapi/spec"
        "github.com/chenwei67/eapi/tag"
)

type ParamNameParser func(field string, tags map[string]string) (name, in string)

type ParamParser struct {
        ctx *Context
        // 解析字段名字和字段所处位置(in. header/path/query/...)
        nameParser ParamNameParser
}

func NewParamParser(ctx *Context, nameParser ParamNameParser) *ParamParser <span class="cov0" title="0">{
        return &amp;ParamParser{ctx: ctx, nameParser: nameParser}
}</span>

// Parse 根据 ast.Expr 解析出 []*spec.Parameter
func (p *ParamParser) Parse(expr ast.Expr) (params []*spec.Parameter) <span class="cov0" title="0">{
        switch expr := expr.(type) </span>{
        case *ast.Ident:<span class="cov0" title="0">
                return p.parseIdent(expr)</span>
        case *ast.StarExpr:<span class="cov0" title="0">
                return p.Parse(expr.X)</span>
        case *ast.UnaryExpr:<span class="cov0" title="0">
                return p.Parse(expr.X)</span>
        case *ast.SelectorExpr:<span class="cov0" title="0">
                return p.Parse(expr.Sel)</span>
        }
        <span class="cov0" title="0">return</span>
}

func (p *ParamParser) parseIdent(expr *ast.Ident) (params []*spec.Parameter) <span class="cov0" title="0">{
        t := p.ctx.Package().TypesInfo.TypeOf(expr)
        if t == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">return p.parseType(t)</span>
}

func (p *ParamParser) parseType(t types.Type) (params []*spec.Parameter) <span class="cov0" title="0">{
        def := p.ctx.ParseType(t)
        typeDef, ok := def.(*TypeDefinition)
        if !ok </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">structType, ok := typeDef.Spec.Type.(*ast.StructType)
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">params = NewParamParser(p.ctx.WithPackage(typeDef.Pkg()).WithFile(typeDef.File()), p.nameParser).parseStructType(structType)
        return</span>
}

func (p *ParamParser) parseStructType(structType *ast.StructType) (params []*spec.Parameter) <span class="cov0" title="0">{
        for _, field := range structType.Fields.List </span><span class="cov0" title="0">{
                if len(field.Names) == 0 </span><span class="cov0" title="0">{ // type composition
                        params = append(params, p.Parse(field.Type)...)
                }</span>

                <span class="cov0" title="0">for _, name := range field.Names </span><span class="cov0" title="0">{
                        param := p.parseField(name, field)
                        params = append(params, param)
                }</span>
        }
        <span class="cov0" title="0">return</span>
}

func (p *ParamParser) parseField(name *ast.Ident, field *ast.Field) (param *spec.Parameter) <span class="cov0" title="0">{
        param = p.typeOf(field.Type)

        param.Name = name.Name
        param.In = "query"
        if field.Tag != nil &amp;&amp; p.nameParser != nil </span><span class="cov0" title="0">{
                tagValues := tag.Parse(field.Tag.Value)
                param.Name, param.In = p.nameParser(name.Name, tagValues)
        }</span>

        // parse comments
        <span class="cov0" title="0">comments := p.ctx.ParseComment(field.Doc)
        if comments != nil </span><span class="cov0" title="0">{
                param.Required = comments.Required()
                param.Description = comments.Text()
                param.Deprecated = comments.Deprecated()
        }</span>

        <span class="cov0" title="0">return</span>
}

func (p *ParamParser) typeOf(expr ast.Expr) *spec.Parameter <span class="cov0" title="0">{
        switch t := expr.(type) </span>{
        case *ast.Ident:<span class="cov0" title="0">
                param := &amp;spec.Parameter{}
                paramSchema := &amp;spec.Schema{}
                paramSchema.Type, paramSchema.Format = p.typeOfIdent(t)
                param.WithSchema(paramSchema)
                return param</span>

        case *ast.SelectorExpr:<span class="cov0" title="0">
                return p.typeOf(t.Sel)</span>

        case *ast.ArrayType:<span class="cov0" title="0">
                param := &amp;spec.Parameter{}
                paramSchema := spec.NewArraySchema(p.typeOf(t.Elt).Schema.NewRef())
                return param.WithSchema(paramSchema)</span>

        case *ast.SliceExpr:<span class="cov0" title="0">
                param := &amp;spec.Parameter{}
                paramSchema := spec.NewArraySchema(p.typeOf(t.X).Schema.NewRef())
                return param.WithSchema(paramSchema)</span>

        case *ast.StarExpr:<span class="cov0" title="0">
                return p.typeOf(t.X)</span>
        }

        // fallback
        <span class="cov0" title="0">param := &amp;spec.Parameter{}
        param.WithSchema(spec.NewStringSchema())
        return param</span>
}

func (p *ParamParser) typeOfIdent(ident *ast.Ident) (string, string) <span class="cov0" title="0">{
        paramType := p.basicType(ident.Name)
        if paramType != "" </span><span class="cov0" title="0">{
                return paramType, ""
        }</span>

        <span class="cov0" title="0">t := p.ctx.Package().TypesInfo.TypeOf(ident)
        if t == nil </span><span class="cov0" title="0">{
                // unknown
                return "", ""
        }</span>

        <span class="cov0" title="0">return p.parseTypeOfType(t)</span>
}

// OpenAPI Parameter types:
// Name                |        type        |         format                |        Comments
// integer        |        integer |        int32                |        signed 32 bits
// long                |        integer |        int64                |        signed 64 bits
// float        |        number         |        float                |
// double        |        number         |        double                |
// string        |        string         |                                |
// byte                |        string         |        byte                |        base64 encoded characters
// binary        |        string         |        binary                |        any sequence of octets
// boolean        |        boolean |                                |
// date                |        string         |        date                |        As defined by full-date - RFC3339
// dateTime        |        string         |        date-time        |        As defined by date-time - RFC3339
// password        |        string         |        password        |        Used to hint UIs the input needs to be obscured.
func (p *ParamParser) basicType(name string) string <span class="cov0" title="0">{
        switch name </span>{
        case "uint", "int", "uint8", "int8", "uint16", "int16",
                "uint32", "int32", "uint64", "int64",
                "byte", "rune":<span class="cov0" title="0">
                return "integer"</span>
        case "float32", "float64":<span class="cov0" title="0">
                return "number"</span>
        case "bool":<span class="cov0" title="0">
                return "boolean"</span>
        case "string":<span class="cov0" title="0">
                return "string"</span>
        }

        <span class="cov0" title="0">return ""</span>
}

func (p *ParamParser) parseTypeOfType(t types.Type) (string, string) <span class="cov0" title="0">{
        switch t := t.(type) </span>{
        case *types.Named:<span class="cov0" title="0">
                p.parseTypeOfType(t.Underlying())</span>
        case *types.Basic:<span class="cov0" title="0">
                return p.parseTypeOfBasicType(t)</span>
        }

        <span class="cov0" title="0">return "", ""</span>
}

func (p *ParamParser) parseTypeOfBasicType(t *types.Basic) (string, string) <span class="cov0" title="0">{
        switch t.Kind() </span>{
        case types.Bool:<span class="cov0" title="0">
                return "boolean", ""</span>
        case types.Int,
                types.Int8,
                types.Int16,
                types.Int32,
                types.Int64,
                types.Uint,
                types.Uint8,
                types.Uint16,
                types.Uint32,
                types.Uint64,
                types.Uintptr:<span class="cov0" title="0">
                return "integer", ""</span>
        case types.Float32,
                types.Float64,
                types.Complex64,
                types.Complex128:<span class="cov0" title="0">
                return "number", ""</span>
        case types.String:<span class="cov0" title="0">
                return "string", ""</span>
        }

        // unknown
        <span class="cov0" title="0">return "", ""</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package eapi

import (
        "go/ast"
        "net/http"
        "strings"

        "github.com/chenwei67/eapi/annotation"
        "github.com/chenwei67/eapi/spec"
)

type RouteGroup struct {
        Prefix string
}

type API struct {
        Method   string
        FullPath string
        Spec     *APISpec
}

func NewAPI(method string, fullPath string) *API <span class="cov0" title="0">{
        return &amp;API{
                Method:   method,
                FullPath: fullPath,
                Spec:     NewAPISpec(),
        }
}</span>

func (r *API) applyToPathItem(pathItem *spec.PathItem) <span class="cov0" title="0">{
        switch r.Method </span>{
        case http.MethodGet:<span class="cov0" title="0">
                pathItem.Get = r.Operation()</span>
        case http.MethodHead:<span class="cov0" title="0">
                pathItem.Head = r.Operation()</span>
        case http.MethodPost:<span class="cov0" title="0">
                pathItem.Post = r.Operation()</span>
        case http.MethodPut:<span class="cov0" title="0">
                pathItem.Put = r.Operation()</span>
        case http.MethodPatch:<span class="cov0" title="0">
                pathItem.Patch = r.Operation()</span>
        case http.MethodDelete:<span class="cov0" title="0">
                pathItem.Delete = r.Operation()</span>
        case http.MethodOptions:<span class="cov0" title="0">
                pathItem.Options = r.Operation()</span>
        case http.MethodTrace:<span class="cov0" title="0">
                pathItem.Trace = r.Operation()</span>
        }
}

func (r *API) Operation() *spec.Operation <span class="cov0" title="0">{
        return r.Spec.Operation
}</span>

type APIs []*API

func (r *APIs) add(items ...*API) <span class="cov0" title="0">{
        *r = append(*r, items...)
}</span>

type APISpec struct {
        Consumes []string
        *spec.Operation
}

func NewAPISpec() *APISpec <span class="cov0" title="0">{
        op := spec.NewOperation()
        op.Responses = spec.NewResponses()
        delete(op.Responses, "default")

        return &amp;APISpec{
                Operation: op,
        }
}</span>

// LoadFromFuncDecl load annotations/description from comments of handler function
func (s *APISpec) LoadFromFuncDecl(ctx *Context, funcDecl *ast.FuncDecl) <span class="cov0" title="0">{
        cg := funcDecl.Doc
        comment := ParseComment(cg, ctx.Package().Fset)
        s.LoadFromComment(ctx, comment)
        if s.Description == "" </span><span class="cov0" title="0">{
                // 使用注释里的普通文本作为描述
                s.Description = strings.TrimSpace(strings.TrimPrefix(comment.Text(), funcDecl.Name.Name))
        }</span>
}

func (s *APISpec) LoadFromComment(ctx *Context, comment *Comment) <span class="cov0" title="0">{
        if comment != nil </span><span class="cov0" title="0">{
                if s.Description == "" </span><span class="cov0" title="0">{
                        s.Description = comment.Text()
                }</span>
                <span class="cov0" title="0">if s.Summary == "" </span><span class="cov0" title="0">{
                        s.Summary = comment.Summary()
                }</span>
                <span class="cov0" title="0">if len(s.Tags) == 0 </span><span class="cov0" title="0">{
                        s.Tags = comment.Tags()
                }</span>
                <span class="cov0" title="0">if s.OperationID == "" </span><span class="cov0" title="0">{
                        s.OperationID = comment.ID()
                }</span>
                <span class="cov0" title="0">if len(s.Consumes) == 0 </span><span class="cov0" title="0">{
                        s.Consumes = append(s.Consumes, comment.Consumes()...)
                }</span>
                <span class="cov0" title="0">if !s.Deprecated </span><span class="cov0" title="0">{
                        comment.Deprecated()
                }</span>
                <span class="cov0" title="0">if s.Security == nil </span><span class="cov0" title="0">{
                        s.Security = comment.Security()
                }</span>
        }
        <span class="cov0" title="0">if len(s.Tags) == 0 </span><span class="cov0" title="0">{
                s.Tags = ctx.CommentStack().LookupTags()
        }</span>
        <span class="cov0" title="0">if s.Security == nil </span><span class="cov0" title="0">{
                s.Security = convertSecAnnotationToSecurityRequirements(ctx.CommentStack().LookupAnnotations(annotation.Security))
        }</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package eapi

import (
        "fmt"
        "go/ast"
        "go/token"
        "go/types"
        "os"
        "strings"

        "github.com/chenwei67/eapi/spec"
        "github.com/chenwei67/eapi/tag"
        "github.com/iancoleman/strcase"
        "github.com/samber/lo"
)

const (
        MimeTypeJson           = "application/json"
        MimeApplicationXml     = "application/xml"
        MimeTypeXml            = "text/xml"
        MimeTypeFormData       = "multipart/form-data"
        MimeTypeFormUrlencoded = "application/x-www-form-urlencoded"
)

type FieldNameParser func(fieldName string, field *ast.Field) string

type SchemaBuilder struct {
        ctx             *Context
        contentType     string
        stack           Stack[string]
        typeArgs        []*spec.SchemaRef
        typeParams      []*spec.TypeParam
        fieldNameParser FieldNameParser
}

func NewSchemaBuilder(ctx *Context, contentType string) *SchemaBuilder <span class="cov0" title="0">{
        return &amp;SchemaBuilder{
                ctx:         ctx,
                contentType: contentType,
        }
}</span>

func newSchemaBuilderWithStack(ctx *Context, contentType string, stack Stack[string]) *SchemaBuilder <span class="cov0" title="0">{
        return &amp;SchemaBuilder{ctx: ctx, contentType: contentType, stack: stack}
}</span>

func (s *SchemaBuilder) WithFieldNameParser(parser FieldNameParser) *SchemaBuilder <span class="cov0" title="0">{
        s.fieldNameParser = parser
        return s
}</span>

func (s *SchemaBuilder) clone() *SchemaBuilder <span class="cov0" title="0">{
        ret := *s
        return &amp;ret
}</span>

func (s *SchemaBuilder) parseTypeDef(def *TypeDefinition) *spec.SchemaRef <span class="cov0" title="0">{
        schemaRef := s.parseTypeSpec(def.Spec)
        if schemaRef == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">schemaRef.Key = def.ModelKey(s.typeArgs...)

        if len(def.Enums) &gt; 0 </span><span class="cov0" title="0">{
                schema := spec.Unref(s.ctx.Doc(), schemaRef)
                ext := spec.NewExtendedEnumType(def.Enums...)
                schema.ExtendedTypeInfo = ext
                for _, item := range def.Enums </span><span class="cov0" title="0">{
                        schema.Enum = append(schema.Enum, item.Value)
                }</span>
        }

        <span class="cov0" title="0">return schemaRef</span>
}

func (s *SchemaBuilder) parseTypeSpec(t *ast.TypeSpec) *spec.SchemaRef <span class="cov0" title="0">{
        var typeParams []*spec.TypeParam
        if t.TypeParams != nil </span><span class="cov0" title="0">{
                for i, field := range t.TypeParams.List </span><span class="cov0" title="0">{
                        for j, name := range field.Names </span><span class="cov0" title="0">{
                                typeParams = append(typeParams, &amp;spec.TypeParam{
                                        Index:      i + j,
                                        Name:       name.Name,
                                        Constraint: field.Type.(*ast.Ident).Name,
                                })
                        }</span>
                }
        }

        <span class="cov0" title="0">schema := s.setTypeParams(typeParams).ParseExpr(t.Type)
        if schema == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">if t.TypeParams != nil </span><span class="cov0" title="0">{
                schema.ExtendedTypeInfo.TypeParams = typeParams
        }</span>

        <span class="cov0" title="0">comment := s.ctx.ParseComment(s.ctx.GetHeadingCommentOf(t.Type.Pos()))
        comment.ApplyToSchema(schema)
        if schema.Ref == "" </span><span class="cov0" title="0">{
                schema.Title = strcase.ToCamel(s.ctx.Package().Name + t.Name.Name)
        }</span>
        <span class="cov0" title="0">return schema</span>
}

func (s *SchemaBuilder) setTypeParams(params []*spec.TypeParam) *SchemaBuilder <span class="cov0" title="0">{
        s.typeParams = params
        return s
}</span>

func (s *SchemaBuilder) setTypeArgs(args ...*spec.SchemaRef) *SchemaBuilder <span class="cov0" title="0">{
        res := *s
        res.typeArgs = args
        return &amp;res
}</span>

func (s *SchemaBuilder) ParseExpr(expr ast.Expr) (schema *spec.SchemaRef) <span class="cov0" title="0">{
        switch expr := expr.(type) </span>{
        case *ast.BasicLit:<span class="cov0" title="0">
                return s.parseBasicLit(expr)</span>

        case *ast.StructType:<span class="cov0" title="0">
                return s.parseStruct(expr)</span>

        case *ast.StarExpr:<span class="cov0" title="0">
                return s.ParseExpr(expr.X)</span>

        case *ast.Ident:<span class="cov0" title="0">
                return s.parseIdent(expr)</span>

        case *ast.SelectorExpr:<span class="cov0" title="0">
                return s.ParseExpr(expr.Sel)</span>

        case *ast.MapType:<span class="cov0" title="0">
                value := s.ParseExpr(expr.Value)
                return spec.NewObjectSchema().
                        WithExtendedType(spec.NewMapExtendedType(
                                s.ParseExpr(expr.Key),
                                value,
                        )).
                        WithAdditionalProperties(value)</span>

        case *ast.ArrayType:<span class="cov0" title="0">
                return spec.NewArraySchema(s.ParseExpr(expr.Elt)).NewRef()</span>

        case *ast.SliceExpr:<span class="cov0" title="0">
                return spec.NewArraySchema(s.ParseExpr(expr.X)).NewRef()</span>

        case *ast.UnaryExpr:<span class="cov0" title="0">
                return s.ParseExpr(expr.X)</span>

        case *ast.CompositeLit:<span class="cov0" title="0">
                return s.ParseExpr(expr.Type)</span>

        case *ast.InterfaceType:<span class="cov0" title="0">
                return spec.NewObjectSchema().WithDescription("Any Type").WithExtendedType(spec.NewAnyExtendedType())</span>

        case *ast.CallExpr:<span class="cov0" title="0">
                return s.parseCallExpr(expr)</span>

        case *ast.IndexExpr:<span class="cov0" title="0">
                return s.parseIndexExpr(expr)</span>

        case *ast.IndexListExpr:<span class="cov0" title="0">
                return s.parseIndexListExpr(expr)</span>

        }

        <span class="cov0" title="0">fmt.Fprintf(os.Stderr, "unknown type at %s\n", s.ctx.LineColumn(expr.Pos()))
        return spec.NewObjectSchema().WithExtendedType(spec.NewUnknownExtType()).NewRef()</span>
}

func (s *SchemaBuilder) parseBasicLit(expr *ast.BasicLit) *spec.SchemaRef <span class="cov0" title="0">{
        switch expr.Kind </span>{
        case token.INT:<span class="cov0" title="0">
                return s.basicType("int")</span>
        case token.FLOAT:<span class="cov0" title="0">
                return s.basicType("float64")</span>
        case token.IMAG:<span class="cov0" title="0">
                return s.basicType("float64")</span>
        case token.CHAR:<span class="cov0" title="0">
                return s.basicType("string")</span>
        case token.STRING:<span class="cov0" title="0">
                return s.basicType("string")</span>
        }

        <span class="cov0" title="0">fmt.Fprintf(os.Stderr, "unknown type at %s\n", s.ctx.LineColumn(expr.Pos()))
        return spec.NewObjectSchema().WithExtendedType(spec.NewUnknownExtType()).NewRef()</span>
}

func (s *SchemaBuilder) parseStruct(expr *ast.StructType) *spec.SchemaRef <span class="cov0" title="0">{
        schema := spec.NewObjectSchema()
        schema.Properties = make(spec.Schemas)

        var contentType = s.contentType
        if s.contentType == "" </span><span class="cov0" title="0">{
                contentType = "application/json" // fallback to json
        }</span>

        <span class="cov0" title="0">for _, field := range expr.Fields.List </span><span class="cov0" title="0">{
                comment := s.parseCommentOfField(field)
                if comment.Ignore() </span><span class="cov0" title="0">{
                        continue</span> // ignored field
                }

                <span class="cov0" title="0">if len(field.Names) == 0 </span><span class="cov0" title="0">{ // type composition
                        fieldSchema := s.ParseExpr(field.Type)
                        if fieldSchema != nil </span><span class="cov0" title="0">{
                                // merge properties
                                fieldSchema = spec.Unref(s.ctx.Doc(), fieldSchema)
                                if fieldSchema != nil </span><span class="cov0" title="0">{
                                        for name, value := range fieldSchema.Properties </span><span class="cov0" title="0">{
                                                schema.Properties[name] = value
                                        }</span>
                                }
                        }
                }

                <span class="cov0" title="0">for _, name := range field.Names </span><span class="cov0" title="0">{
                        if !name.IsExported() </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">fieldSchema := s.ParseExpr(field.Type)
                        if fieldSchema == nil </span><span class="cov0" title="0">{
                                s.ctx.StrictWarn("unknown field type %s at %s", name.Name, s.ctx.LineColumn(field.Type.Pos()))
                                continue</span>
                        }
                        <span class="cov0" title="0">propName := s.getPropName(name.Name, field, contentType)
                        if propName == "-" </span><span class="cov0" title="0">{ // ignore
                                continue</span>
                        }

                        <span class="cov0" title="0">if comment != nil </span><span class="cov0" title="0">{
                                comment.ApplyToSchema(fieldSchema)
                                if comment.Required() </span><span class="cov0" title="0">{
                                        schema.Required = append(schema.Required, propName)
                                }</span>
                        }
                        <span class="cov0" title="0">schema.Properties[propName] = fieldSchema</span>
                }
        }

        <span class="cov0" title="0">return schema</span>
}

func (s *SchemaBuilder) parseIdent(expr *ast.Ident) *spec.SchemaRef <span class="cov0" title="0">{
        t := s.ctx.Package().TypesInfo.TypeOf(expr)
        if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return s.parseType(t)</span>
}

var commonTypes = map[string]*spec.Schema{
        "time.Time": spec.NewSchema().WithType("string").WithFormat("datetime"),
        "encoding/json.RawMessage": spec.NewSchema().
                WithType("object").
                WithDescription("Any Json Type").
                WithExtendedType(spec.NewAnyExtendedType()),
        "json.RawMessage": spec.NewSchema().
                WithType("object").
                WithDescription("Any Json Type").
                WithExtendedType(spec.NewAnyExtendedType()),
        "database/sql.NullTime":    spec.NewDateTimeSchema(),
        "database/sql.NullString":  spec.NewStringSchema(),
        "database/sql.NullInt64":   spec.NewInt64Schema(),
        "database/sql.NullInt32":   spec.NewInt32Schema(),
        "database/sql.NullInt":     spec.NewIntegerSchema(),
        "database/sql.NullInt16":   spec.NewIntegerSchema(),
        "database/sql.NullFloat64": spec.NewFloat64Schema(),
        "database/sql.NullBool":    spec.NewBoolSchema(),
        "database/sql.NullByte":    spec.NewStringSchema(),
}

func (s *SchemaBuilder) commonUsedType(t types.Type) *spec.SchemaRef <span class="cov0" title="0">{
        switch t := t.(type) </span>{
        case *types.Named:<span class="cov0" title="0">
                if t.Obj() == nil || t.Obj().Pkg() == nil </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">typeName := t.Obj().Pkg().Path() + "." + t.Obj().Name()
                commonType, ok := commonTypes[typeName]
                if !ok </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">return commonType.Clone()</span>

        case *types.Pointer:<span class="cov0" title="0">
                return s.commonUsedType(t.Elem())</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (s *SchemaBuilder) parseSelectorExpr(expr *ast.SelectorExpr) *spec.SchemaRef <span class="cov0" title="0">{
        return s.ParseExpr(expr.Sel)
}</span>

func (s *SchemaBuilder) getPropName(fieldName string, field *ast.Field, contentType string) (propName string) <span class="cov0" title="0">{
        if s.fieldNameParser != nil </span><span class="cov0" title="0">{
                return s.fieldNameParser(fieldName, field)
        }</span>

        <span class="cov0" title="0">if field.Tag == nil </span><span class="cov0" title="0">{
                return fieldName
        }</span>

        <span class="cov0" title="0">tags := tag.Parse(field.Tag.Value)
        var tagValue string
        switch contentType </span>{
        case MimeTypeJson:<span class="cov0" title="0">
                tagValue = tags["json"]</span>
        case MimeTypeXml, MimeApplicationXml:<span class="cov0" title="0">
                tagValue = tags["xml"]</span>
        case MimeTypeFormData, MimeTypeFormUrlencoded:<span class="cov0" title="0">
                tagValue = tags["form"]</span>
        }
        <span class="cov0" title="0">if tagValue == "" </span><span class="cov0" title="0">{
                return fieldName
        }</span>

        <span class="cov0" title="0">propName, _, _ = strings.Cut(tagValue, ",")
        return</span>
}

func (s *SchemaBuilder) basicType(name string) *spec.SchemaRef <span class="cov0" title="0">{
        switch name </span>{
        case "uint", "int", "uint8", "int8", "uint16", "int16",
                "uint32", "int32", "uint64", "int64":<span class="cov0" title="0">
                return spec.NewIntegerSchema()</span>
        case "byte", "rune":<span class="cov0" title="0">
                return spec.NewBytesSchema()</span>
        case "float32", "float64":<span class="cov0" title="0">
                return spec.NewFloat64Schema()</span>
        case "bool":<span class="cov0" title="0">
                return spec.NewBoolSchema()</span>
        case "string":<span class="cov0" title="0">
                return spec.NewStringSchema()</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (s *SchemaBuilder) inParsingStack(key string) bool <span class="cov0" title="0">{
        return lo.Contains(s.stack, key)
}</span>

func (s *SchemaBuilder) parseType(t types.Type) *spec.SchemaRef <span class="cov0" title="0">{
        var typeArgs = s.typeArgs

        switch t := t.(type) </span>{
        case *types.Basic:<span class="cov0" title="0">
                return s.basicType(t.Name())</span>
        case *types.Interface:<span class="cov0" title="0">
                return spec.NewObjectSchema().
                        WithDescription("Any Type").
                        WithExtendedType(spec.NewAnyExtendedType()).NewRef()</span>
        case *types.TypeParam:<span class="cov0" title="0">
                return spec.NewTypeParamSchema(s.typeParams[t.Index()]).NewRef()</span>
        case *types.Slice:<span class="cov0" title="0">
                return spec.NewArraySchema(s.parseType(t.Elem())).NewRef()</span>
        case *types.Array:<span class="cov0" title="0">
                return spec.NewArraySchema(s.parseType(t.Elem())).NewRef()</span>
        case *types.Pointer:<span class="cov0" title="0">
                return s.parseType(t.Elem())</span>
        case *types.Map:<span class="cov0" title="0">
                valueType := s.parseType(t.Elem())
                keyType := s.parseType(t.Key())
                return spec.NewObjectSchema().
                        WithAdditionalProperties(valueType).
                        WithExtendedType(spec.NewMapExtendedType(keyType, valueType)).
                        NewRef()</span>
        case *types.Named:<span class="cov0" title="0">
                // parse type arguments
                args := t.TypeArgs()
                if args.Len() &gt; 0 </span><span class="cov0" title="0">{
                        typeArgs = make([]*spec.SchemaRef, 0)
                        for i := 0; i &lt; args.Len(); i++ </span><span class="cov0" title="0">{
                                typeArgs = append(typeArgs, s.parseType(args.At(i)))
                        }</span>
                }
        default:<span class="cov0" title="0"></span>
        }

        // 检查是否是常用类型
        <span class="cov0" title="0">schema := s.commonUsedType(t)
        if schema != nil </span><span class="cov0" title="0">{
                return schema
        }</span>

        <span class="cov0" title="0">def := s.ctx.ParseType(t)
        typeDef, ok := def.(*TypeDefinition)
        if !ok </span><span class="cov0" title="0">{
                var contextInfo string
                if s.ctx.Package() != nil </span><span class="cov0" title="0">{
                        contextInfo = fmt.Sprintf(" in package %s", s.ctx.Package().PkgPath)
                }</span>
                <span class="cov0" title="0">if s.ctx.File() != nil </span><span class="cov0" title="0">{
                        contextInfo += fmt.Sprintf(" at file %s", s.ctx.File().Name.Name)
                }</span>
                <span class="cov0" title="0">s.ctx.StrictError("unknown type %s%s, def type: %T", t.String(), contextInfo, def)
                return spec.NewSchema().WithExtendedType(spec.NewUnknownExtType()).NewRef()</span>
        }

        <span class="cov0" title="0">modelKey := typeDef.ModelKey()
        refKey := typeDef.RefKey()
        if s.inParsingStack(modelKey) </span><span class="cov0" title="0">{
                return spec.RefSchema(refKey)
        }</span>

        <span class="cov0" title="0">schema, schemaExists := s.ctx.Doc().Components.Schemas[modelKey]
        if !schemaExists </span><span class="cov0" title="0">{
                s.stack.Push(modelKey)
                defer s.stack.Pop()

                schema = newSchemaBuilderWithStack(s.ctx.WithPackage(typeDef.pkg).WithFile(typeDef.file), s.contentType, s.stack).
                        WithFieldNameParser(s.fieldNameParser).
                        setTypeArgs().
                        parseTypeDef(typeDef)
                s.ctx.Doc().Components.Schemas[typeDef.ModelKey()] = schema
        }</span>

        <span class="cov0" title="0">schemaRef := spec.RefSchema(refKey)
        if len(typeArgs) &gt; 0 </span><span class="cov0" title="0">{
                return spec.NewSchema().WithExtendedType(spec.NewSpecificExtendType(schemaRef, typeArgs...)).NewRef()
        }</span>
        <span class="cov0" title="0">return schemaRef</span>
}

func (s *SchemaBuilder) parseCommentOfField(field *ast.Field) *Comment <span class="cov0" title="0">{
        // heading comment
        if field.Doc != nil &amp;&amp; len(field.Doc.List) &gt; 0 </span><span class="cov0" title="0">{
                return ParseCommentWithContext(field.Doc, s.ctx.Package().Fset, s.ctx)
        }</span>

        // parse trailing comment
        <span class="cov0" title="0">commentGroup := s.ctx.GetTrailingCommentOf(field.Pos())
        return ParseCommentWithContext(commentGroup, s.ctx.Package().Fset, s.ctx)</span>
}

func (s *SchemaBuilder) parseCallExpr(expr *ast.CallExpr) *spec.SchemaRef <span class="cov0" title="0">{
        t := s.ctx.Package().TypesInfo.TypeOf(expr)
        return s.parseType(t)
}</span>

func (s *SchemaBuilder) parseIndexExpr(expr *ast.IndexExpr) *spec.SchemaRef <span class="cov0" title="0">{
        var argType *spec.SchemaRef
        if s.isTypeParam(expr.Index) </span><span class="cov0" title="0">{
                t := s.ctx.Package().TypesInfo.TypeOf(expr.Index).(*types.TypeParam)
                argType = spec.NewTypeParamSchema(s.typeParams[t.Index()]).NewRef()
        }</span> else<span class="cov0" title="0"> {
                argType = s.ParseExpr(expr.Index)
        }</span>
        <span class="cov0" title="0">genericType := s.clone().setTypeArgs().setTypeParams(nil).ParseExpr(expr.X)
        if genericType == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return spec.NewSchema().WithExtendedType(spec.NewSpecificExtendType(genericType, argType)).NewRef()</span>
}

func (s *SchemaBuilder) parseIndexListExpr(expr *ast.IndexListExpr) *spec.SchemaRef <span class="cov0" title="0">{
        var typeArgs []*spec.SchemaRef
        for _, param := range expr.Indices </span><span class="cov0" title="0">{
                var typeArg *spec.SchemaRef
                if s.isTypeParam(param) </span><span class="cov0" title="0">{
                        t := s.ctx.Package().TypesInfo.TypeOf(param).(*types.TypeParam)
                        typeArg = spec.NewTypeParamSchema(s.typeParams[t.Index()]).NewRef()
                }</span> else<span class="cov0" title="0"> {
                        typeArg = s.ParseExpr(param)
                }</span>
                <span class="cov0" title="0">typeArgs = append(typeArgs, typeArg)</span>
        }
        <span class="cov0" title="0">genericType := s.setTypeArgs().setTypeParams(nil).ParseExpr(expr.X)
        if genericType == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return spec.NewSchema().WithExtendedType(spec.NewSpecificExtendType(genericType, typeArgs...)).NewRef()</span>
}

func (s *SchemaBuilder) getTypeKey(expr ast.Expr) string <span class="cov0" title="0">{
        t := s.ctx.Package().TypesInfo.TypeOf(expr)
        switch t := t.(type) </span>{
        case *types.Basic:<span class="cov0" title="0">
                return t.Name()</span>
        default:<span class="cov0" title="0">
                def := s.ctx.ParseType(t)
                if def == nil </span><span class="cov0" title="0">{
                        s.ctx.StrictWarn("unknown type at %s", s.ctx.LineColumn(expr.Pos()))
                        return ""
                }</span>
                <span class="cov0" title="0">return def.(*TypeDefinition).ModelKey()</span>
        }
}

// 判断表达式是否是泛型类型形参
func (s *SchemaBuilder) isTypeParam(index ast.Expr) bool <span class="cov0" title="0">{
        t := s.ctx.Package().TypesInfo.TypeOf(index)
        _, ok := t.(*types.TypeParam)
        return ok
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package eapi

type Stack[T any] []T

func (s *Stack[T]) Push(v T) <span class="cov0" title="0">{
        *s = append(*s, v)
}</span>

func (s *Stack[T]) Pop() *T <span class="cov0" title="0">{
        if len(*s) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">res := (*s)[len(*s)-1]
        *s = (*s)[:len(*s)-1]
        return &amp;res</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package eapi

import (
        "go/types"
        "os"
        "path/filepath"
        "strconv"
        "strings"

        "github.com/spf13/cast"
        "golang.org/x/mod/modfile"
        "golang.org/x/tools/go/packages"
)

var DEBUG = os.Getenv("DEBUG") == "on"

func InspectPackage(pkg *packages.Package, visit func(pkg *packages.Package) bool) <span class="cov0" title="0">{
        if !visit(pkg) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">for _, p := range pkg.Imports </span><span class="cov0" title="0">{
                InspectPackage(p, visit)
        }</span>
}

func NormalizeComment(text, trimStart string) string <span class="cov0" title="0">{
        text = strings.TrimSpace(text)
        text = strings.TrimPrefix(text, trimStart)
        return text
}</span>

func ReadGoMod(pkgPath string) (mod *modfile.File, err error) <span class="cov0" title="0">{
        fileName := filepath.Join(pkgPath, "go.mod")
        content, err := os.ReadFile(fileName)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">mod, err = modfile.Parse("go.mod", content, nil)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">return</span>
}

func ConvertStrToBasicType(str string, t *types.Basic) interface{} <span class="cov0" title="0">{
        switch t.Kind() </span>{
        case types.Bool:<span class="cov0" title="0">
                return cast.ToBool(str)</span>
        case types.Int, types.Int8, types.Int16, types.Int32, types.Int64:<span class="cov0" title="0">
                val, _ := strconv.ParseInt(str, 10, 64)
                return val</span>
        case types.Uint, types.Uint8, types.Uint16, types.Uint32, types.Uint64:<span class="cov0" title="0">
                val, _ := strconv.ParseUint(str, 10, 64)
                return val</span>
        case types.Float32, types.Float64:<span class="cov0" title="0">
                return cast.ToFloat64(str)</span>
        case types.String:<span class="cov0" title="0">
                return strings.Trim(str, "\"")</span>
        default:<span class="cov0" title="0">
                return str</span>
        }
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
